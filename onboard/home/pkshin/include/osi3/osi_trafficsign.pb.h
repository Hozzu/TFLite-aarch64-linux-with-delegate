// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_trafficsign.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_osi_5ftrafficsign_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_osi_5ftrafficsign_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "osi_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_osi_5ftrafficsign_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_osi_5ftrafficsign_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_osi_5ftrafficsign_2eproto;
namespace osi3 {
class TrafficSign;
class TrafficSignDefaultTypeInternal;
extern TrafficSignDefaultTypeInternal _TrafficSign_default_instance_;
class TrafficSignValue;
class TrafficSignValueDefaultTypeInternal;
extern TrafficSignValueDefaultTypeInternal _TrafficSignValue_default_instance_;
class TrafficSign_MainSign;
class TrafficSign_MainSignDefaultTypeInternal;
extern TrafficSign_MainSignDefaultTypeInternal _TrafficSign_MainSign_default_instance_;
class TrafficSign_MainSign_Classification;
class TrafficSign_MainSign_ClassificationDefaultTypeInternal;
extern TrafficSign_MainSign_ClassificationDefaultTypeInternal _TrafficSign_MainSign_Classification_default_instance_;
class TrafficSign_SupplementarySign;
class TrafficSign_SupplementarySignDefaultTypeInternal;
extern TrafficSign_SupplementarySignDefaultTypeInternal _TrafficSign_SupplementarySign_default_instance_;
class TrafficSign_SupplementarySign_Classification;
class TrafficSign_SupplementarySign_ClassificationDefaultTypeInternal;
extern TrafficSign_SupplementarySign_ClassificationDefaultTypeInternal _TrafficSign_SupplementarySign_Classification_default_instance_;
class TrafficSign_SupplementarySign_Classification_Arrow;
class TrafficSign_SupplementarySign_Classification_ArrowDefaultTypeInternal;
extern TrafficSign_SupplementarySign_Classification_ArrowDefaultTypeInternal _TrafficSign_SupplementarySign_Classification_Arrow_default_instance_;
}  // namespace osi3
PROTOBUF_NAMESPACE_OPEN
template<> ::osi3::TrafficSign* Arena::CreateMaybeMessage<::osi3::TrafficSign>(Arena*);
template<> ::osi3::TrafficSignValue* Arena::CreateMaybeMessage<::osi3::TrafficSignValue>(Arena*);
template<> ::osi3::TrafficSign_MainSign* Arena::CreateMaybeMessage<::osi3::TrafficSign_MainSign>(Arena*);
template<> ::osi3::TrafficSign_MainSign_Classification* Arena::CreateMaybeMessage<::osi3::TrafficSign_MainSign_Classification>(Arena*);
template<> ::osi3::TrafficSign_SupplementarySign* Arena::CreateMaybeMessage<::osi3::TrafficSign_SupplementarySign>(Arena*);
template<> ::osi3::TrafficSign_SupplementarySign_Classification* Arena::CreateMaybeMessage<::osi3::TrafficSign_SupplementarySign_Classification>(Arena*);
template<> ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* Arena::CreateMaybeMessage<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace osi3 {

enum TrafficSignValue_Unit : int {
  TrafficSignValue_Unit_UNIT_UNKNOWN = 0,
  TrafficSignValue_Unit_UNIT_OTHER = 1,
  TrafficSignValue_Unit_UNIT_NO_UNIT = 2,
  TrafficSignValue_Unit_UNIT_KILOMETER_PER_HOUR = 3,
  TrafficSignValue_Unit_UNIT_MILE_PER_HOUR = 4,
  TrafficSignValue_Unit_UNIT_METER = 5,
  TrafficSignValue_Unit_UNIT_KILOMETER = 6,
  TrafficSignValue_Unit_UNIT_FEET = 7,
  TrafficSignValue_Unit_UNIT_MILE = 8,
  TrafficSignValue_Unit_UNIT_METRIC_TON = 9,
  TrafficSignValue_Unit_UNIT_LONG_TON = 10,
  TrafficSignValue_Unit_UNIT_SHORT_TON = 11,
  TrafficSignValue_Unit_UNIT_MINUTES = 12,
  TrafficSignValue_Unit_UNIT_DAY = 13,
  TrafficSignValue_Unit_UNIT_PERCENTAGE = 14
};
bool TrafficSignValue_Unit_IsValid(int value);
constexpr TrafficSignValue_Unit TrafficSignValue_Unit_Unit_MIN = TrafficSignValue_Unit_UNIT_UNKNOWN;
constexpr TrafficSignValue_Unit TrafficSignValue_Unit_Unit_MAX = TrafficSignValue_Unit_UNIT_PERCENTAGE;
constexpr int TrafficSignValue_Unit_Unit_ARRAYSIZE = TrafficSignValue_Unit_Unit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSignValue_Unit_descriptor();
template<typename T>
inline const std::string& TrafficSignValue_Unit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSignValue_Unit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSignValue_Unit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSignValue_Unit_descriptor(), enum_t_value);
}
inline bool TrafficSignValue_Unit_Parse(
    const std::string& name, TrafficSignValue_Unit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSignValue_Unit>(
    TrafficSignValue_Unit_descriptor(), name, value);
}
enum TrafficSign_MainSign_Classification_Type : int {
  TrafficSign_MainSign_Classification_Type_TYPE_UNKNOWN = 0,
  TrafficSign_MainSign_Classification_Type_TYPE_OTHER = 1,
  TrafficSign_MainSign_Classification_Type_TYPE_DANGER_SPOT = 2,
  TrafficSign_MainSign_Classification_Type_TYPE_ZEBRA_CROSSING = 87,
  TrafficSign_MainSign_Classification_Type_TYPE_FLIGHT = 110,
  TrafficSign_MainSign_Classification_Type_TYPE_CATTLE = 200,
  TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS = 197,
  TrafficSign_MainSign_Classification_Type_TYPE_AMPHIBIANS = 188,
  TrafficSign_MainSign_Classification_Type_TYPE_FALLING_ROCKS = 96,
  TrafficSign_MainSign_Classification_Type_TYPE_SNOW_OR_ICE = 94,
  TrafficSign_MainSign_Classification_Type_TYPE_LOOSE_GRAVEL = 97,
  TrafficSign_MainSign_Classification_Type_TYPE_WATERSIDE = 102,
  TrafficSign_MainSign_Classification_Type_TYPE_CLEARANCE = 210,
  TrafficSign_MainSign_Classification_Type_TYPE_MOVABLE_BRIDGE = 101,
  TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION = 3,
  TrafficSign_MainSign_Classification_Type_TYPE_TURN_LEFT = 4,
  TrafficSign_MainSign_Classification_Type_TYPE_TURN_RIGHT = 5,
  TrafficSign_MainSign_Classification_Type_TYPE_DOUBLE_TURN_LEFT = 6,
  TrafficSign_MainSign_Classification_Type_TYPE_DOUBLE_TURN_RIGHT = 7,
  TrafficSign_MainSign_Classification_Type_TYPE_HILL_DOWNWARDS = 8,
  TrafficSign_MainSign_Classification_Type_TYPE_HILL_UPWARDS = 9,
  TrafficSign_MainSign_Classification_Type_TYPE_UNEVEN_ROAD = 93,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_SLIPPERY_WET_OR_DIRTY = 95,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDE_WINDS = 98,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING = 10,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING_RIGHT = 12,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING_LEFT = 11,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_WORKS = 13,
  TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_QUEUES = 100,
  TrafficSign_MainSign_Classification_Type_TYPE_TWO_WAY_TRAFFIC = 14,
  TrafficSign_MainSign_Classification_Type_TYPE_ATTENTION_TRAFFIC_LIGHT = 15,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS = 103,
  TrafficSign_MainSign_Classification_Type_TYPE_CHILDREN_CROSSING = 106,
  TrafficSign_MainSign_Classification_Type_TYPE_CYCLE_ROUTE = 107,
  TrafficSign_MainSign_Classification_Type_TYPE_DEER_CROSSING = 109,
  TrafficSign_MainSign_Classification_Type_TYPE_UNGATED_LEVEL_CROSSING = 144,
  TrafficSign_MainSign_Classification_Type_TYPE_LEVEL_CROSSING_MARKER = 112,
  TrafficSign_MainSign_Classification_Type_TYPE_RAILWAY_TRAFFIC_PRIORITY = 135,
  TrafficSign_MainSign_Classification_Type_TYPE_GIVE_WAY = 16,
  TrafficSign_MainSign_Classification_Type_TYPE_STOP = 17,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_TO_OPPOSITE_DIRECTION = 18,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN = 19,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN = 20,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_TURN = 21,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_STRAIGHT = 22,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_WAY = 24,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_WAY = 23,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT = 26,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT = 25,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN = 27,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT = 28,
  TrafficSign_MainSign_Classification_Type_TYPE_ROUNDABOUT = 29,
  TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_LEFT = 30,
  TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_RIGHT = 31,
  TrafficSign_MainSign_Classification_Type_TYPE_PASS_LEFT = 32,
  TrafficSign_MainSign_Classification_Type_TYPE_PASS_RIGHT = 33,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC = 128,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC = 129,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC = 130,
  TrafficSign_MainSign_Classification_Type_TYPE_BUS_STOP = 137,
  TrafficSign_MainSign_Classification_Type_TYPE_TAXI_STAND = 138,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_ONLY = 145,
  TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS_ONLY = 146,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS_ONLY = 147,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY = 148,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY = 149,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY = 150,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_ZONE_BEGIN = 151,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_ZONE_END = 152,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLE_ROAD_BEGIN = 153,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLE_ROAD_END = 154,
  TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE = 34,
  TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE_BEGIN = 35,
  TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE_END = 36,
  TrafficSign_MainSign_Classification_Type_TYPE_ALL_PROHIBITED = 37,
  TrafficSign_MainSign_Classification_Type_TYPE_MOTORIZED_MULTITRACK_PROHIBITED = 38,
  TrafficSign_MainSign_Classification_Type_TYPE_TRUCKS_PROHIBITED = 39,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PROHIBITED = 40,
  TrafficSign_MainSign_Classification_Type_TYPE_MOTORCYCLES_PROHIBITED = 41,
  TrafficSign_MainSign_Classification_Type_TYPE_MOPEDS_PROHIBITED = 155,
  TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS_PROHIBITED = 156,
  TrafficSign_MainSign_Classification_Type_TYPE_HORSE_CARRIAGES_PROHIBITED = 157,
  TrafficSign_MainSign_Classification_Type_TYPE_CATTLE_PROHIBITED = 158,
  TrafficSign_MainSign_Classification_Type_TYPE_BUSES_PROHIBITED = 159,
  TrafficSign_MainSign_Classification_Type_TYPE_CARS_PROHIBITED = 160,
  TrafficSign_MainSign_Classification_Type_TYPE_CARS_TRAILERS_PROHIBITED = 161,
  TrafficSign_MainSign_Classification_Type_TYPE_TRUCKS_TRAILERS_PROHIBITED = 162,
  TrafficSign_MainSign_Classification_Type_TYPE_TRACTORS_PROHIBITED = 163,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS_PROHIBITED = 42,
  TrafficSign_MainSign_Classification_Type_TYPE_MOTOR_VEHICLES_PROHIBITED = 43,
  TrafficSign_MainSign_Classification_Type_TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED = 164,
  TrafficSign_MainSign_Classification_Type_TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED = 165,
  TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED = 166,
  TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED = 167,
  TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED = 168,
  TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED = 169,
  TrafficSign_MainSign_Classification_Type_TYPE_DO_NOT_ENTER = 44,
  TrafficSign_MainSign_Classification_Type_TYPE_SNOW_CHAINS_REQUIRED = 170,
  TrafficSign_MainSign_Classification_Type_TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED = 171,
  TrafficSign_MainSign_Classification_Type_TYPE_ENVIRONMENTAL_ZONE_BEGIN = 45,
  TrafficSign_MainSign_Classification_Type_TYPE_ENVIRONMENTAL_ZONE_END = 46,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_U_TURN_LEFT = 47,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_U_TURN_RIGHT = 48,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_U_TURN_LEFT = 49,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_U_TURN_RIGHT = 50,
  TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_DISTANCE_FOR_TRUCKS = 51,
  TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_BEGIN = 52,
  TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_ZONE_BEGIN = 53,
  TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_ZONE_END = 54,
  TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_SPEED_BEGIN = 55,
  TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_BEGIN = 56,
  TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN = 57,
  TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_END = 58,
  TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_SPEED_END = 59,
  TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_END = 60,
  TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_FOR_TRUCKS_END = 61,
  TrafficSign_MainSign_Classification_Type_TYPE_ALL_RESTRICTIONS_END = 62,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_STOPPING = 63,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING = 64,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING_ZONE_BEGIN = 65,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING_ZONE_END = 66,
  TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION = 67,
  TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_BEGIN = 68,
  TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_END = 69,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION = 70,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN = 71,
  TrafficSign_MainSign_Classification_Type_TYPE_TOWN_BEGIN = 72,
  TrafficSign_MainSign_Classification_Type_TYPE_TOWN_END = 73,
  TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING = 74,
  TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING_ZONE_BEGIN = 75,
  TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING_ZONE_END = 76,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_HALF_PARKING_LEFT = 172,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_HALF_PARKING_RIGHT = 173,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PARKING_LEFT = 174,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PARKING_RIGHT = 175,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT = 176,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT = 177,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT = 178,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT = 179,
  TrafficSign_MainSign_Classification_Type_TYPE_LIVING_STREET_BEGIN = 77,
  TrafficSign_MainSign_Classification_Type_TYPE_LIVING_STREET_END = 78,
  TrafficSign_MainSign_Classification_Type_TYPE_TUNNEL = 79,
  TrafficSign_MainSign_Classification_Type_TYPE_EMERGENCY_STOPPING_LEFT = 80,
  TrafficSign_MainSign_Classification_Type_TYPE_EMERGENCY_STOPPING_RIGHT = 81,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_BEGIN = 82,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_END = 83,
  TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_BEGIN = 84,
  TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_END = 85,
  TrafficSign_MainSign_Classification_Type_TYPE_NAMED_HIGHWAY_EXIT = 183,
  TrafficSign_MainSign_Classification_Type_TYPE_NAMED_EXPRESSWAY_EXIT = 184,
  TrafficSign_MainSign_Classification_Type_TYPE_NAMED_ROAD_EXIT = 185,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_EXIT = 86,
  TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_EXIT = 186,
  TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_STREET = 187,
  TrafficSign_MainSign_Classification_Type_TYPE_CROSSING_GUARDS = 189,
  TrafficSign_MainSign_Classification_Type_TYPE_DEADEND = 190,
  TrafficSign_MainSign_Classification_Type_TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS = 191,
  TrafficSign_MainSign_Classification_Type_TYPE_FIRST_AID_STATION = 194,
  TrafficSign_MainSign_Classification_Type_TYPE_POLICE_STATION = 195,
  TrafficSign_MainSign_Classification_Type_TYPE_TELEPHONE = 196,
  TrafficSign_MainSign_Classification_Type_TYPE_FILLING_STATION = 198,
  TrafficSign_MainSign_Classification_Type_TYPE_HOTEL = 201,
  TrafficSign_MainSign_Classification_Type_TYPE_INN = 202,
  TrafficSign_MainSign_Classification_Type_TYPE_KIOSK = 203,
  TrafficSign_MainSign_Classification_Type_TYPE_TOILET = 204,
  TrafficSign_MainSign_Classification_Type_TYPE_CHAPEL = 205,
  TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_INFO = 206,
  TrafficSign_MainSign_Classification_Type_TYPE_REPAIR_SERVICE = 207,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_UNDERPASS = 208,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_BRIDGE = 209,
  TrafficSign_MainSign_Classification_Type_TYPE_CAMPER_PLACE = 213,
  TrafficSign_MainSign_Classification_Type_TYPE_ADVISORY_SPEED_LIMIT_BEGIN = 214,
  TrafficSign_MainSign_Classification_Type_TYPE_ADVISORY_SPEED_LIMIT_END = 215,
  TrafficSign_MainSign_Classification_Type_TYPE_PLACE_NAME = 216,
  TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_ATTRACTION = 217,
  TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_ROUTE = 218,
  TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_AREA = 219,
  TrafficSign_MainSign_Classification_Type_TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES = 220,
  TrafficSign_MainSign_Classification_Type_TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS = 221,
  TrafficSign_MainSign_Classification_Type_TYPE_TOLL_BEGIN = 222,
  TrafficSign_MainSign_Classification_Type_TYPE_TOLL_END = 223,
  TrafficSign_MainSign_Classification_Type_TYPE_TOLL_ROAD = 224,
  TrafficSign_MainSign_Classification_Type_TYPE_CUSTOMS = 225,
  TrafficSign_MainSign_Classification_Type_TYPE_INTERNATIONAL_BORDER_INFO = 226,
  TrafficSign_MainSign_Classification_Type_TYPE_STREETLIGHT_RED_BAND = 227,
  TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER = 228,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ROUTE_NUMBER = 229,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_INTERCHANGE_NUMBER = 230,
  TrafficSign_MainSign_Classification_Type_TYPE_EUROPEAN_ROUTE_NUMBER = 231,
  TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT = 232,
  TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT = 233,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIMARY_ROAD_DIRECTION_LEFT = 234,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIMARY_ROAD_DIRECTION_RIGHT = 235,
  TrafficSign_MainSign_Classification_Type_TYPE_SECONDARY_ROAD_DIRECTION_LEFT = 236,
  TrafficSign_MainSign_Classification_Type_TYPE_SECONDARY_ROAD_DIRECTION_RIGHT = 237,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT = 238,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT = 239,
  TrafficSign_MainSign_Classification_Type_TYPE_ROUTING_DESIGNATED_ACTORS = 240,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_HIGHWAY_LEFT = 143,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_HIGHWAY_RIGHT = 108,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT = 127,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT = 136,
  TrafficSign_MainSign_Classification_Type_TYPE_CONSOLIDATED_DIRECTIONS = 118,
  TrafficSign_MainSign_Classification_Type_TYPE_STREET_NAME = 119,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT = 120,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG = 121,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES = 122,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ANNOUNCEMENT = 123,
  TrafficSign_MainSign_Classification_Type_TYPE_OTHER_ROAD_ANNOUNCEMENT = 124,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP = 125,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS = 126,
  TrafficSign_MainSign_Classification_Type_TYPE_POLE_EXIT = 88,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_DISTANCE_BOARD = 180,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_LEFT = 181,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_RIGHT = 182,
  TrafficSign_MainSign_Classification_Type_TYPE_NUMBERED_DETOUR = 131,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_BEGIN = 132,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_END = 133,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_ROUTING_BOARD = 134,
  TrafficSign_MainSign_Classification_Type_TYPE_OPTIONAL_DETOUR = 111,
  TrafficSign_MainSign_Classification_Type_TYPE_OPTIONAL_DETOUR_ROUTING = 199,
  TrafficSign_MainSign_Classification_Type_TYPE_ROUTE_RECOMMENDATION = 211,
  TrafficSign_MainSign_Classification_Type_TYPE_ROUTE_RECOMMENDATION_END = 212,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_TRANSITION_LEFT = 192,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT = 193,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_RIGHT_LANE_END = 90,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LEFT_LANE_END = 89,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_RIGHT_LANE_BEGIN = 115,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LEFT_LANE_BEGIN = 116,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_CONSOLIDATION = 117,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_CITY_BLOCK = 142,
  TrafficSign_MainSign_Classification_Type_TYPE_GATE = 141,
  TrafficSign_MainSign_Classification_Type_TYPE_POLE_WARNING = 91,
  TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_CONE = 140,
  TrafficSign_MainSign_Classification_Type_TYPE_MOBILE_LANE_CLOSURE = 139,
  TrafficSign_MainSign_Classification_Type_TYPE_REFLECTOR_POST = 114,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTIONAL_BOARD_WARNING = 113,
  TrafficSign_MainSign_Classification_Type_TYPE_GUIDING_PLATE = 104,
  TrafficSign_MainSign_Classification_Type_TYPE_GUIDING_PLATE_WEDGES = 105,
  TrafficSign_MainSign_Classification_Type_TYPE_PARKING_HAZARD = 99,
  TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_LIGHT_GREEN_ARROW = 92
};
bool TrafficSign_MainSign_Classification_Type_IsValid(int value);
constexpr TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification_Type_Type_MIN = TrafficSign_MainSign_Classification_Type_TYPE_UNKNOWN;
constexpr TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification_Type_Type_MAX = TrafficSign_MainSign_Classification_Type_TYPE_ROUTING_DESIGNATED_ACTORS;
constexpr int TrafficSign_MainSign_Classification_Type_Type_ARRAYSIZE = TrafficSign_MainSign_Classification_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSign_MainSign_Classification_Type_descriptor();
template<typename T>
inline const std::string& TrafficSign_MainSign_Classification_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSign_MainSign_Classification_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSign_MainSign_Classification_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSign_MainSign_Classification_Type_descriptor(), enum_t_value);
}
inline bool TrafficSign_MainSign_Classification_Type_Parse(
    const std::string& name, TrafficSign_MainSign_Classification_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSign_MainSign_Classification_Type>(
    TrafficSign_MainSign_Classification_Type_descriptor(), name, value);
}
enum TrafficSign_MainSign_Classification_DirectionScope : int {
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_UNKNOWN = 0,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_OTHER = 1,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_NO_DIRECTION = 2,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT = 3,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_RIGHT = 4,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT_RIGHT = 5
};
bool TrafficSign_MainSign_Classification_DirectionScope_IsValid(int value);
constexpr TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MIN = TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_UNKNOWN;
constexpr TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MAX = TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT_RIGHT;
constexpr int TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_ARRAYSIZE = TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSign_MainSign_Classification_DirectionScope_descriptor();
template<typename T>
inline const std::string& TrafficSign_MainSign_Classification_DirectionScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSign_MainSign_Classification_DirectionScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSign_MainSign_Classification_DirectionScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSign_MainSign_Classification_DirectionScope_descriptor(), enum_t_value);
}
inline bool TrafficSign_MainSign_Classification_DirectionScope_Parse(
    const std::string& name, TrafficSign_MainSign_Classification_DirectionScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSign_MainSign_Classification_DirectionScope>(
    TrafficSign_MainSign_Classification_DirectionScope_descriptor(), name, value);
}
enum TrafficSign_SupplementarySign_Classification_Arrow_Direction : int {
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_UNKNOWN = 0,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_OTHER = 1,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_NO_DIRECTION = 2,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_0_DEG = 3,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_45_DEG_RIGHT = 4,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_45_DEG_LEFT = 5,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_90_DEG_RIGHT = 6,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_90_DEG_LEFT = 7,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_135_DEG_RIGHT = 8,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_135_DEG_LEFT = 9,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_180_DEG = 10,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_45_DEG_RIGHT = 11,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_45_DEG_LEFT = 12,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_90_DEG_RIGHT = 13,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_90_DEG_LEFT = 14,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_135_DEG_RIGHT = 15,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_135_DEG_LEFT = 16,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_180_DEG_RIGHT = 17,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_180_DEG_LEFT = 18,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_0_DEG = 19,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_45_DEG_RIGHT = 20,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_45_DEG_LEFT = 21,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_90_DEG_RIGHT = 22,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_90_DEG_LEFT = 23,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_135_DEG_RIGHT = 24,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_135_DEG_LEFT = 25,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_180_DEG = 26,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_TO_TURN_0_DEG = 27,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG = 28,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT = 29,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT = 30,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT = 31,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT = 32
};
bool TrafficSign_SupplementarySign_Classification_Arrow_Direction_IsValid(int value);
constexpr TrafficSign_SupplementarySign_Classification_Arrow_Direction TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MIN = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_UNKNOWN;
constexpr TrafficSign_SupplementarySign_Classification_Arrow_Direction TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MAX = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT;
constexpr int TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_ARRAYSIZE = TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor();
template<typename T>
inline const std::string& TrafficSign_SupplementarySign_Classification_Arrow_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSign_SupplementarySign_Classification_Arrow_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSign_SupplementarySign_Classification_Arrow_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor(), enum_t_value);
}
inline bool TrafficSign_SupplementarySign_Classification_Arrow_Direction_Parse(
    const std::string& name, TrafficSign_SupplementarySign_Classification_Arrow_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSign_SupplementarySign_Classification_Arrow_Direction>(
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor(), name, value);
}
enum TrafficSign_SupplementarySign_Classification_Type : int {
  TrafficSign_SupplementarySign_Classification_Type_TYPE_UNKNOWN = 0,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_OTHER = 1,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_NO_SIGN = 2,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TEXT = 41,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_SPACE = 39,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TIME = 26,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_ARROW = 30,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_CONSTRAINED_TO = 46,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_EXCEPT = 45,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_VALID_FOR_DISTANCE = 3,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY = 27,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY = 28,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT = 32,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS = 33,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT = 34,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY = 29,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY = 31,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT = 35,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY = 36,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT = 37,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_VALID_IN_DISTANCE = 4,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_STOP_IN = 25,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_LEFT_ARROW = 11,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_LEFT_BEND_ARROW = 13,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_RIGHT_ARROW = 12,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_RIGHT_BEND_ARROW = 14,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_ACCIDENT = 40,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_SNOW = 9,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_FOG = 8,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_ROLLING_HIGHWAY_INFORMATION = 48,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_SERVICES = 47,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TIME_RANGE = 5,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PARKING_DISC_TIME_RESTRICTION = 43,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_WEIGHT = 6,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_WET = 44,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PARKING_CONSTRAINT = 42,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_NO_WAITING_SIDE_STRIPES = 38,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_RAIN = 7,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_SNOW_RAIN = 10,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_NIGHT = 19,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_STOP_4_WAY = 21,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TRUCK = 15,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TRACTORS_MAY_BE_PASSED = 16,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_HAZARDOUS = 17,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TRAILER = 18,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_ZONE = 20,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_MOTORCYCLE = 22,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_MOTORCYCLE_ALLOWED = 23,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_CAR = 24
};
bool TrafficSign_SupplementarySign_Classification_Type_IsValid(int value);
constexpr TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification_Type_Type_MIN = TrafficSign_SupplementarySign_Classification_Type_TYPE_UNKNOWN;
constexpr TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification_Type_Type_MAX = TrafficSign_SupplementarySign_Classification_Type_TYPE_ROLLING_HIGHWAY_INFORMATION;
constexpr int TrafficSign_SupplementarySign_Classification_Type_Type_ARRAYSIZE = TrafficSign_SupplementarySign_Classification_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSign_SupplementarySign_Classification_Type_descriptor();
template<typename T>
inline const std::string& TrafficSign_SupplementarySign_Classification_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSign_SupplementarySign_Classification_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSign_SupplementarySign_Classification_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSign_SupplementarySign_Classification_Type_descriptor(), enum_t_value);
}
inline bool TrafficSign_SupplementarySign_Classification_Type_Parse(
    const std::string& name, TrafficSign_SupplementarySign_Classification_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSign_SupplementarySign_Classification_Type>(
    TrafficSign_SupplementarySign_Classification_Type_descriptor(), name, value);
}
enum TrafficSign_SupplementarySign_Classification_Actor : int {
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_UNKNOWN = 0,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_OTHER = 1,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_NO_ACTOR = 2,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_AGRICULTURAL_VEHICLES = 3,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_BICYCLES = 4,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_BUSES = 5,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CAMPERS = 6,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARAVANS = 7,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS = 8,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS_WITH_CARAVANS = 9,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS_WITH_TRAILERS = 10,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CATTLE = 11,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CHILDREN = 12,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CONSTRUCTION_VEHICLES = 13,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_DELIVERY_VEHICLES = 14,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_DISABLED_PERSONS = 15,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_EBIKES = 16,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_ELECTRIC_VEHICLES = 17,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_EMERGENCY_VEHICLES = 18,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_FERRY_USERS = 19,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_FORESTRY_VEHICLES = 20,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HAZARDOUS_GOODS_VEHICLES = 21,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HORSE_CARRIAGES = 22,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HORSE_RIDERS = 23,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_INLINE_SKATERS = 24,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MEDICAL_VEHICLES = 25,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MILITARY_VEHICLES = 26,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOPEDS = 27,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOTORCYCLES = 28,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOTORIZED_MULTITRACK_VEHICLES = 29,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES = 30,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_PEDESTRIANS = 31,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_PUBLIC_TRANSPORT_VEHICLES = 32,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_RAILROAD_TRAFFIC = 33,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_RESIDENTS = 34,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_SLURRY_TRANSPORT = 35,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TAXIS = 36,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRACTORS = 37,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRAILERS = 38,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRAMS = 39,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS = 40,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS_WITH_SEMITRAILERS = 41,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS_WITH_TRAILERS = 42,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_GREEN_BADGES = 43,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_RED_BADGES = 44,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_YELLOW_BADGES = 45,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WATER_POLLUTANT_VEHICLES = 46,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WINTER_SPORTSPEOPLE = 47
};
bool TrafficSign_SupplementarySign_Classification_Actor_IsValid(int value);
constexpr TrafficSign_SupplementarySign_Classification_Actor TrafficSign_SupplementarySign_Classification_Actor_Actor_MIN = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_UNKNOWN;
constexpr TrafficSign_SupplementarySign_Classification_Actor TrafficSign_SupplementarySign_Classification_Actor_Actor_MAX = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WINTER_SPORTSPEOPLE;
constexpr int TrafficSign_SupplementarySign_Classification_Actor_Actor_ARRAYSIZE = TrafficSign_SupplementarySign_Classification_Actor_Actor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSign_SupplementarySign_Classification_Actor_descriptor();
template<typename T>
inline const std::string& TrafficSign_SupplementarySign_Classification_Actor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSign_SupplementarySign_Classification_Actor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSign_SupplementarySign_Classification_Actor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSign_SupplementarySign_Classification_Actor_descriptor(), enum_t_value);
}
inline bool TrafficSign_SupplementarySign_Classification_Actor_Parse(
    const std::string& name, TrafficSign_SupplementarySign_Classification_Actor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSign_SupplementarySign_Classification_Actor>(
    TrafficSign_SupplementarySign_Classification_Actor_descriptor(), name, value);
}
enum TrafficSign_Variability : int {
  TrafficSign_Variability_VARIABILITY_UNKNOWN = 0,
  TrafficSign_Variability_VARIABILITY_OTHER = 1,
  TrafficSign_Variability_VARIABILITY_FIXED = 2,
  TrafficSign_Variability_VARIABILITY_VARIABLE = 3
};
bool TrafficSign_Variability_IsValid(int value);
constexpr TrafficSign_Variability TrafficSign_Variability_Variability_MIN = TrafficSign_Variability_VARIABILITY_UNKNOWN;
constexpr TrafficSign_Variability TrafficSign_Variability_Variability_MAX = TrafficSign_Variability_VARIABILITY_VARIABLE;
constexpr int TrafficSign_Variability_Variability_ARRAYSIZE = TrafficSign_Variability_Variability_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficSign_Variability_descriptor();
template<typename T>
inline const std::string& TrafficSign_Variability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficSign_Variability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficSign_Variability_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficSign_Variability_descriptor(), enum_t_value);
}
inline bool TrafficSign_Variability_Parse(
    const std::string& name, TrafficSign_Variability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficSign_Variability>(
    TrafficSign_Variability_descriptor(), name, value);
}
// ===================================================================

class TrafficSignValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.TrafficSignValue) */ {
 public:
  TrafficSignValue();
  virtual ~TrafficSignValue();

  TrafficSignValue(const TrafficSignValue& from);
  TrafficSignValue(TrafficSignValue&& from) noexcept
    : TrafficSignValue() {
    *this = ::std::move(from);
  }

  inline TrafficSignValue& operator=(const TrafficSignValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSignValue& operator=(TrafficSignValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSignValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSignValue* internal_default_instance() {
    return reinterpret_cast<const TrafficSignValue*>(
               &_TrafficSignValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TrafficSignValue& a, TrafficSignValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSignValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSignValue* New() const final {
    return CreateMaybeMessage<TrafficSignValue>(nullptr);
  }

  TrafficSignValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSignValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSignValue& from);
  void MergeFrom(const TrafficSignValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSignValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.TrafficSignValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ftrafficsign_2eproto);
    return ::descriptor_table_osi_5ftrafficsign_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSignValue_Unit Unit;
  static constexpr Unit UNIT_UNKNOWN =
    TrafficSignValue_Unit_UNIT_UNKNOWN;
  static constexpr Unit UNIT_OTHER =
    TrafficSignValue_Unit_UNIT_OTHER;
  static constexpr Unit UNIT_NO_UNIT =
    TrafficSignValue_Unit_UNIT_NO_UNIT;
  static constexpr Unit UNIT_KILOMETER_PER_HOUR =
    TrafficSignValue_Unit_UNIT_KILOMETER_PER_HOUR;
  static constexpr Unit UNIT_MILE_PER_HOUR =
    TrafficSignValue_Unit_UNIT_MILE_PER_HOUR;
  static constexpr Unit UNIT_METER =
    TrafficSignValue_Unit_UNIT_METER;
  static constexpr Unit UNIT_KILOMETER =
    TrafficSignValue_Unit_UNIT_KILOMETER;
  static constexpr Unit UNIT_FEET =
    TrafficSignValue_Unit_UNIT_FEET;
  static constexpr Unit UNIT_MILE =
    TrafficSignValue_Unit_UNIT_MILE;
  static constexpr Unit UNIT_METRIC_TON =
    TrafficSignValue_Unit_UNIT_METRIC_TON;
  static constexpr Unit UNIT_LONG_TON =
    TrafficSignValue_Unit_UNIT_LONG_TON;
  static constexpr Unit UNIT_SHORT_TON =
    TrafficSignValue_Unit_UNIT_SHORT_TON;
  static constexpr Unit UNIT_MINUTES =
    TrafficSignValue_Unit_UNIT_MINUTES;
  static constexpr Unit UNIT_DAY =
    TrafficSignValue_Unit_UNIT_DAY;
  static constexpr Unit UNIT_PERCENTAGE =
    TrafficSignValue_Unit_UNIT_PERCENTAGE;
  static inline bool Unit_IsValid(int value) {
    return TrafficSignValue_Unit_IsValid(value);
  }
  static constexpr Unit Unit_MIN =
    TrafficSignValue_Unit_Unit_MIN;
  static constexpr Unit Unit_MAX =
    TrafficSignValue_Unit_Unit_MAX;
  static constexpr int Unit_ARRAYSIZE =
    TrafficSignValue_Unit_Unit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Unit_descriptor() {
    return TrafficSignValue_Unit_descriptor();
  }
  template<typename T>
  static inline const std::string& Unit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Unit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Unit_Name.");
    return TrafficSignValue_Unit_Name(enum_t_value);
  }
  static inline bool Unit_Parse(const std::string& name,
      Unit* value) {
    return TrafficSignValue_Unit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kValueFieldNumber = 1,
    kValueUnitFieldNumber = 2,
  };
  // optional string text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional double value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // optional .osi3.TrafficSignValue.Unit value_unit = 2;
  bool has_value_unit() const;
  private:
  bool _internal_has_value_unit() const;
  public:
  void clear_value_unit();
  ::osi3::TrafficSignValue_Unit value_unit() const;
  void set_value_unit(::osi3::TrafficSignValue_Unit value);
  private:
  ::osi3::TrafficSignValue_Unit _internal_value_unit() const;
  void _internal_set_value_unit(::osi3::TrafficSignValue_Unit value);
  public:

  // @@protoc_insertion_point(class_scope:osi3.TrafficSignValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  double value_;
  int value_unit_;
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_MainSign_Classification :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.TrafficSign.MainSign.Classification) */ {
 public:
  TrafficSign_MainSign_Classification();
  virtual ~TrafficSign_MainSign_Classification();

  TrafficSign_MainSign_Classification(const TrafficSign_MainSign_Classification& from);
  TrafficSign_MainSign_Classification(TrafficSign_MainSign_Classification&& from) noexcept
    : TrafficSign_MainSign_Classification() {
    *this = ::std::move(from);
  }

  inline TrafficSign_MainSign_Classification& operator=(const TrafficSign_MainSign_Classification& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_MainSign_Classification& operator=(TrafficSign_MainSign_Classification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSign_MainSign_Classification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_MainSign_Classification* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_MainSign_Classification*>(
               &_TrafficSign_MainSign_Classification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TrafficSign_MainSign_Classification& a, TrafficSign_MainSign_Classification& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_MainSign_Classification* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_MainSign_Classification* New() const final {
    return CreateMaybeMessage<TrafficSign_MainSign_Classification>(nullptr);
  }

  TrafficSign_MainSign_Classification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_MainSign_Classification>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSign_MainSign_Classification& from);
  void MergeFrom(const TrafficSign_MainSign_Classification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_MainSign_Classification* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.TrafficSign.MainSign.Classification";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ftrafficsign_2eproto);
    return ::descriptor_table_osi_5ftrafficsign_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSign_MainSign_Classification_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    TrafficSign_MainSign_Classification_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_OTHER =
    TrafficSign_MainSign_Classification_Type_TYPE_OTHER;
  static constexpr Type TYPE_DANGER_SPOT =
    TrafficSign_MainSign_Classification_Type_TYPE_DANGER_SPOT;
  static constexpr Type TYPE_ZEBRA_CROSSING =
    TrafficSign_MainSign_Classification_Type_TYPE_ZEBRA_CROSSING;
  static constexpr Type TYPE_FLIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_FLIGHT;
  static constexpr Type TYPE_CATTLE =
    TrafficSign_MainSign_Classification_Type_TYPE_CATTLE;
  static constexpr Type TYPE_HORSE_RIDERS =
    TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS;
  static constexpr Type TYPE_AMPHIBIANS =
    TrafficSign_MainSign_Classification_Type_TYPE_AMPHIBIANS;
  static constexpr Type TYPE_FALLING_ROCKS =
    TrafficSign_MainSign_Classification_Type_TYPE_FALLING_ROCKS;
  static constexpr Type TYPE_SNOW_OR_ICE =
    TrafficSign_MainSign_Classification_Type_TYPE_SNOW_OR_ICE;
  static constexpr Type TYPE_LOOSE_GRAVEL =
    TrafficSign_MainSign_Classification_Type_TYPE_LOOSE_GRAVEL;
  static constexpr Type TYPE_WATERSIDE =
    TrafficSign_MainSign_Classification_Type_TYPE_WATERSIDE;
  static constexpr Type TYPE_CLEARANCE =
    TrafficSign_MainSign_Classification_Type_TYPE_CLEARANCE;
  static constexpr Type TYPE_MOVABLE_BRIDGE =
    TrafficSign_MainSign_Classification_Type_TYPE_MOVABLE_BRIDGE;
  static constexpr Type TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION =
    TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION;
  static constexpr Type TYPE_TURN_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_TURN_LEFT;
  static constexpr Type TYPE_TURN_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_TURN_RIGHT;
  static constexpr Type TYPE_DOUBLE_TURN_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_DOUBLE_TURN_LEFT;
  static constexpr Type TYPE_DOUBLE_TURN_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_DOUBLE_TURN_RIGHT;
  static constexpr Type TYPE_HILL_DOWNWARDS =
    TrafficSign_MainSign_Classification_Type_TYPE_HILL_DOWNWARDS;
  static constexpr Type TYPE_HILL_UPWARDS =
    TrafficSign_MainSign_Classification_Type_TYPE_HILL_UPWARDS;
  static constexpr Type TYPE_UNEVEN_ROAD =
    TrafficSign_MainSign_Classification_Type_TYPE_UNEVEN_ROAD;
  static constexpr Type TYPE_ROAD_SLIPPERY_WET_OR_DIRTY =
    TrafficSign_MainSign_Classification_Type_TYPE_ROAD_SLIPPERY_WET_OR_DIRTY;
  static constexpr Type TYPE_SIDE_WINDS =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDE_WINDS;
  static constexpr Type TYPE_ROAD_NARROWING =
    TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING;
  static constexpr Type TYPE_ROAD_NARROWING_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING_RIGHT;
  static constexpr Type TYPE_ROAD_NARROWING_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING_LEFT;
  static constexpr Type TYPE_ROAD_WORKS =
    TrafficSign_MainSign_Classification_Type_TYPE_ROAD_WORKS;
  static constexpr Type TYPE_TRAFFIC_QUEUES =
    TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_QUEUES;
  static constexpr Type TYPE_TWO_WAY_TRAFFIC =
    TrafficSign_MainSign_Classification_Type_TYPE_TWO_WAY_TRAFFIC;
  static constexpr Type TYPE_ATTENTION_TRAFFIC_LIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_ATTENTION_TRAFFIC_LIGHT;
  static constexpr Type TYPE_PEDESTRIANS =
    TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS;
  static constexpr Type TYPE_CHILDREN_CROSSING =
    TrafficSign_MainSign_Classification_Type_TYPE_CHILDREN_CROSSING;
  static constexpr Type TYPE_CYCLE_ROUTE =
    TrafficSign_MainSign_Classification_Type_TYPE_CYCLE_ROUTE;
  static constexpr Type TYPE_DEER_CROSSING =
    TrafficSign_MainSign_Classification_Type_TYPE_DEER_CROSSING;
  static constexpr Type TYPE_UNGATED_LEVEL_CROSSING =
    TrafficSign_MainSign_Classification_Type_TYPE_UNGATED_LEVEL_CROSSING;
  static constexpr Type TYPE_LEVEL_CROSSING_MARKER =
    TrafficSign_MainSign_Classification_Type_TYPE_LEVEL_CROSSING_MARKER;
  static constexpr Type TYPE_RAILWAY_TRAFFIC_PRIORITY =
    TrafficSign_MainSign_Classification_Type_TYPE_RAILWAY_TRAFFIC_PRIORITY;
  static constexpr Type TYPE_GIVE_WAY =
    TrafficSign_MainSign_Classification_Type_TYPE_GIVE_WAY;
  static constexpr Type TYPE_STOP =
    TrafficSign_MainSign_Classification_Type_TYPE_STOP;
  static constexpr Type TYPE_PRIORITY_TO_OPPOSITE_DIRECTION =
    TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_TO_OPPOSITE_DIRECTION;
  static constexpr Type TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN =
    TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN;
  static constexpr Type TYPE_PRESCRIBED_LEFT_TURN =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN;
  static constexpr Type TYPE_PRESCRIBED_RIGHT_TURN =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_TURN;
  static constexpr Type TYPE_PRESCRIBED_STRAIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_STRAIGHT;
  static constexpr Type TYPE_PRESCRIBED_RIGHT_WAY =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_WAY;
  static constexpr Type TYPE_PRESCRIBED_LEFT_WAY =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_WAY;
  static constexpr Type TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT;
  static constexpr Type TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT;
  static constexpr Type TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN;
  static constexpr Type TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT;
  static constexpr Type TYPE_ROUNDABOUT =
    TrafficSign_MainSign_Classification_Type_TYPE_ROUNDABOUT;
  static constexpr Type TYPE_ONEWAY_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_LEFT;
  static constexpr Type TYPE_ONEWAY_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_RIGHT;
  static constexpr Type TYPE_PASS_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_PASS_LEFT;
  static constexpr Type TYPE_PASS_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_PASS_RIGHT;
  static constexpr Type TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC;
  static constexpr Type TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC;
  static constexpr Type TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC;
  static constexpr Type TYPE_BUS_STOP =
    TrafficSign_MainSign_Classification_Type_TYPE_BUS_STOP;
  static constexpr Type TYPE_TAXI_STAND =
    TrafficSign_MainSign_Classification_Type_TYPE_TAXI_STAND;
  static constexpr Type TYPE_BICYCLES_ONLY =
    TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_ONLY;
  static constexpr Type TYPE_HORSE_RIDERS_ONLY =
    TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS_ONLY;
  static constexpr Type TYPE_PEDESTRIANS_ONLY =
    TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS_ONLY;
  static constexpr Type TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY =
    TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY;
  static constexpr Type TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY =
    TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY;
  static constexpr Type TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY =
    TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY;
  static constexpr Type TYPE_PEDESTRIAN_ZONE_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_ZONE_BEGIN;
  static constexpr Type TYPE_PEDESTRIAN_ZONE_END =
    TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_ZONE_END;
  static constexpr Type TYPE_BICYCLE_ROAD_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_BICYCLE_ROAD_BEGIN;
  static constexpr Type TYPE_BICYCLE_ROAD_END =
    TrafficSign_MainSign_Classification_Type_TYPE_BICYCLE_ROAD_END;
  static constexpr Type TYPE_BUS_LANE =
    TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE;
  static constexpr Type TYPE_BUS_LANE_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE_BEGIN;
  static constexpr Type TYPE_BUS_LANE_END =
    TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE_END;
  static constexpr Type TYPE_ALL_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_ALL_PROHIBITED;
  static constexpr Type TYPE_MOTORIZED_MULTITRACK_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_MOTORIZED_MULTITRACK_PROHIBITED;
  static constexpr Type TYPE_TRUCKS_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_TRUCKS_PROHIBITED;
  static constexpr Type TYPE_BICYCLES_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PROHIBITED;
  static constexpr Type TYPE_MOTORCYCLES_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_MOTORCYCLES_PROHIBITED;
  static constexpr Type TYPE_MOPEDS_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_MOPEDS_PROHIBITED;
  static constexpr Type TYPE_HORSE_RIDERS_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS_PROHIBITED;
  static constexpr Type TYPE_HORSE_CARRIAGES_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_HORSE_CARRIAGES_PROHIBITED;
  static constexpr Type TYPE_CATTLE_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_CATTLE_PROHIBITED;
  static constexpr Type TYPE_BUSES_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_BUSES_PROHIBITED;
  static constexpr Type TYPE_CARS_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_CARS_PROHIBITED;
  static constexpr Type TYPE_CARS_TRAILERS_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_CARS_TRAILERS_PROHIBITED;
  static constexpr Type TYPE_TRUCKS_TRAILERS_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_TRUCKS_TRAILERS_PROHIBITED;
  static constexpr Type TYPE_TRACTORS_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_TRACTORS_PROHIBITED;
  static constexpr Type TYPE_PEDESTRIANS_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS_PROHIBITED;
  static constexpr Type TYPE_MOTOR_VEHICLES_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_MOTOR_VEHICLES_PROHIBITED;
  static constexpr Type TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED;
  static constexpr Type TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED;
  static constexpr Type TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED;
  static constexpr Type TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED;
  static constexpr Type TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED;
  static constexpr Type TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED;
  static constexpr Type TYPE_DO_NOT_ENTER =
    TrafficSign_MainSign_Classification_Type_TYPE_DO_NOT_ENTER;
  static constexpr Type TYPE_SNOW_CHAINS_REQUIRED =
    TrafficSign_MainSign_Classification_Type_TYPE_SNOW_CHAINS_REQUIRED;
  static constexpr Type TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED =
    TrafficSign_MainSign_Classification_Type_TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED;
  static constexpr Type TYPE_ENVIRONMENTAL_ZONE_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_ENVIRONMENTAL_ZONE_BEGIN;
  static constexpr Type TYPE_ENVIRONMENTAL_ZONE_END =
    TrafficSign_MainSign_Classification_Type_TYPE_ENVIRONMENTAL_ZONE_END;
  static constexpr Type TYPE_NO_U_TURN_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_NO_U_TURN_LEFT;
  static constexpr Type TYPE_NO_U_TURN_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_NO_U_TURN_RIGHT;
  static constexpr Type TYPE_PRESCRIBED_U_TURN_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_U_TURN_LEFT;
  static constexpr Type TYPE_PRESCRIBED_U_TURN_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_U_TURN_RIGHT;
  static constexpr Type TYPE_MINIMUM_DISTANCE_FOR_TRUCKS =
    TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_DISTANCE_FOR_TRUCKS;
  static constexpr Type TYPE_SPEED_LIMIT_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_BEGIN;
  static constexpr Type TYPE_SPEED_LIMIT_ZONE_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_ZONE_BEGIN;
  static constexpr Type TYPE_SPEED_LIMIT_ZONE_END =
    TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_ZONE_END;
  static constexpr Type TYPE_MINIMUM_SPEED_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_SPEED_BEGIN;
  static constexpr Type TYPE_OVERTAKING_BAN_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_BEGIN;
  static constexpr Type TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN;
  static constexpr Type TYPE_SPEED_LIMIT_END =
    TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_END;
  static constexpr Type TYPE_MINIMUM_SPEED_END =
    TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_SPEED_END;
  static constexpr Type TYPE_OVERTAKING_BAN_END =
    TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_END;
  static constexpr Type TYPE_OVERTAKING_BAN_FOR_TRUCKS_END =
    TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_FOR_TRUCKS_END;
  static constexpr Type TYPE_ALL_RESTRICTIONS_END =
    TrafficSign_MainSign_Classification_Type_TYPE_ALL_RESTRICTIONS_END;
  static constexpr Type TYPE_NO_STOPPING =
    TrafficSign_MainSign_Classification_Type_TYPE_NO_STOPPING;
  static constexpr Type TYPE_NO_PARKING =
    TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING;
  static constexpr Type TYPE_NO_PARKING_ZONE_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING_ZONE_BEGIN;
  static constexpr Type TYPE_NO_PARKING_ZONE_END =
    TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING_ZONE_END;
  static constexpr Type TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION =
    TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION;
  static constexpr Type TYPE_RIGHT_OF_WAY_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_BEGIN;
  static constexpr Type TYPE_RIGHT_OF_WAY_END =
    TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_END;
  static constexpr Type TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION =
    TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION;
  static constexpr Type TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN =
    TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN;
  static constexpr Type TYPE_TOWN_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_TOWN_BEGIN;
  static constexpr Type TYPE_TOWN_END =
    TrafficSign_MainSign_Classification_Type_TYPE_TOWN_END;
  static constexpr Type TYPE_CAR_PARKING =
    TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING;
  static constexpr Type TYPE_CAR_PARKING_ZONE_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING_ZONE_BEGIN;
  static constexpr Type TYPE_CAR_PARKING_ZONE_END =
    TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING_ZONE_END;
  static constexpr Type TYPE_SIDEWALK_HALF_PARKING_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_HALF_PARKING_LEFT;
  static constexpr Type TYPE_SIDEWALK_HALF_PARKING_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_HALF_PARKING_RIGHT;
  static constexpr Type TYPE_SIDEWALK_PARKING_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PARKING_LEFT;
  static constexpr Type TYPE_SIDEWALK_PARKING_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PARKING_RIGHT;
  static constexpr Type TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT;
  static constexpr Type TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT;
  static constexpr Type TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT;
  static constexpr Type TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT;
  static constexpr Type TYPE_LIVING_STREET_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_LIVING_STREET_BEGIN;
  static constexpr Type TYPE_LIVING_STREET_END =
    TrafficSign_MainSign_Classification_Type_TYPE_LIVING_STREET_END;
  static constexpr Type TYPE_TUNNEL =
    TrafficSign_MainSign_Classification_Type_TYPE_TUNNEL;
  static constexpr Type TYPE_EMERGENCY_STOPPING_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_EMERGENCY_STOPPING_LEFT;
  static constexpr Type TYPE_EMERGENCY_STOPPING_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_EMERGENCY_STOPPING_RIGHT;
  static constexpr Type TYPE_HIGHWAY_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_BEGIN;
  static constexpr Type TYPE_HIGHWAY_END =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_END;
  static constexpr Type TYPE_EXPRESSWAY_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_BEGIN;
  static constexpr Type TYPE_EXPRESSWAY_END =
    TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_END;
  static constexpr Type TYPE_NAMED_HIGHWAY_EXIT =
    TrafficSign_MainSign_Classification_Type_TYPE_NAMED_HIGHWAY_EXIT;
  static constexpr Type TYPE_NAMED_EXPRESSWAY_EXIT =
    TrafficSign_MainSign_Classification_Type_TYPE_NAMED_EXPRESSWAY_EXIT;
  static constexpr Type TYPE_NAMED_ROAD_EXIT =
    TrafficSign_MainSign_Classification_Type_TYPE_NAMED_ROAD_EXIT;
  static constexpr Type TYPE_HIGHWAY_EXIT =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_EXIT;
  static constexpr Type TYPE_EXPRESSWAY_EXIT =
    TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_EXIT;
  static constexpr Type TYPE_ONEWAY_STREET =
    TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_STREET;
  static constexpr Type TYPE_CROSSING_GUARDS =
    TrafficSign_MainSign_Classification_Type_TYPE_CROSSING_GUARDS;
  static constexpr Type TYPE_DEADEND =
    TrafficSign_MainSign_Classification_Type_TYPE_DEADEND;
  static constexpr Type TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS =
    TrafficSign_MainSign_Classification_Type_TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS;
  static constexpr Type TYPE_FIRST_AID_STATION =
    TrafficSign_MainSign_Classification_Type_TYPE_FIRST_AID_STATION;
  static constexpr Type TYPE_POLICE_STATION =
    TrafficSign_MainSign_Classification_Type_TYPE_POLICE_STATION;
  static constexpr Type TYPE_TELEPHONE =
    TrafficSign_MainSign_Classification_Type_TYPE_TELEPHONE;
  static constexpr Type TYPE_FILLING_STATION =
    TrafficSign_MainSign_Classification_Type_TYPE_FILLING_STATION;
  static constexpr Type TYPE_HOTEL =
    TrafficSign_MainSign_Classification_Type_TYPE_HOTEL;
  static constexpr Type TYPE_INN =
    TrafficSign_MainSign_Classification_Type_TYPE_INN;
  static constexpr Type TYPE_KIOSK =
    TrafficSign_MainSign_Classification_Type_TYPE_KIOSK;
  static constexpr Type TYPE_TOILET =
    TrafficSign_MainSign_Classification_Type_TYPE_TOILET;
  static constexpr Type TYPE_CHAPEL =
    TrafficSign_MainSign_Classification_Type_TYPE_CHAPEL;
  static constexpr Type TYPE_TOURIST_INFO =
    TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_INFO;
  static constexpr Type TYPE_REPAIR_SERVICE =
    TrafficSign_MainSign_Classification_Type_TYPE_REPAIR_SERVICE;
  static constexpr Type TYPE_PEDESTRIAN_UNDERPASS =
    TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_UNDERPASS;
  static constexpr Type TYPE_PEDESTRIAN_BRIDGE =
    TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_BRIDGE;
  static constexpr Type TYPE_CAMPER_PLACE =
    TrafficSign_MainSign_Classification_Type_TYPE_CAMPER_PLACE;
  static constexpr Type TYPE_ADVISORY_SPEED_LIMIT_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_ADVISORY_SPEED_LIMIT_BEGIN;
  static constexpr Type TYPE_ADVISORY_SPEED_LIMIT_END =
    TrafficSign_MainSign_Classification_Type_TYPE_ADVISORY_SPEED_LIMIT_END;
  static constexpr Type TYPE_PLACE_NAME =
    TrafficSign_MainSign_Classification_Type_TYPE_PLACE_NAME;
  static constexpr Type TYPE_TOURIST_ATTRACTION =
    TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_ATTRACTION;
  static constexpr Type TYPE_TOURIST_ROUTE =
    TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_ROUTE;
  static constexpr Type TYPE_TOURIST_AREA =
    TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_AREA;
  static constexpr Type TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES =
    TrafficSign_MainSign_Classification_Type_TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES;
  static constexpr Type TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS =
    TrafficSign_MainSign_Classification_Type_TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS;
  static constexpr Type TYPE_TOLL_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_TOLL_BEGIN;
  static constexpr Type TYPE_TOLL_END =
    TrafficSign_MainSign_Classification_Type_TYPE_TOLL_END;
  static constexpr Type TYPE_TOLL_ROAD =
    TrafficSign_MainSign_Classification_Type_TYPE_TOLL_ROAD;
  static constexpr Type TYPE_CUSTOMS =
    TrafficSign_MainSign_Classification_Type_TYPE_CUSTOMS;
  static constexpr Type TYPE_INTERNATIONAL_BORDER_INFO =
    TrafficSign_MainSign_Classification_Type_TYPE_INTERNATIONAL_BORDER_INFO;
  static constexpr Type TYPE_STREETLIGHT_RED_BAND =
    TrafficSign_MainSign_Classification_Type_TYPE_STREETLIGHT_RED_BAND;
  static constexpr Type TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER =
    TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER;
  static constexpr Type TYPE_HIGHWAY_ROUTE_NUMBER =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ROUTE_NUMBER;
  static constexpr Type TYPE_HIGHWAY_INTERCHANGE_NUMBER =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_INTERCHANGE_NUMBER;
  static constexpr Type TYPE_EUROPEAN_ROUTE_NUMBER =
    TrafficSign_MainSign_Classification_Type_TYPE_EUROPEAN_ROUTE_NUMBER;
  static constexpr Type TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT;
  static constexpr Type TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT;
  static constexpr Type TYPE_PRIMARY_ROAD_DIRECTION_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_PRIMARY_ROAD_DIRECTION_LEFT;
  static constexpr Type TYPE_PRIMARY_ROAD_DIRECTION_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_PRIMARY_ROAD_DIRECTION_RIGHT;
  static constexpr Type TYPE_SECONDARY_ROAD_DIRECTION_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_SECONDARY_ROAD_DIRECTION_LEFT;
  static constexpr Type TYPE_SECONDARY_ROAD_DIRECTION_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_SECONDARY_ROAD_DIRECTION_RIGHT;
  static constexpr Type TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT;
  static constexpr Type TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT;
  static constexpr Type TYPE_ROUTING_DESIGNATED_ACTORS =
    TrafficSign_MainSign_Classification_Type_TYPE_ROUTING_DESIGNATED_ACTORS;
  static constexpr Type TYPE_DIRECTION_TO_HIGHWAY_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_HIGHWAY_LEFT;
  static constexpr Type TYPE_DIRECTION_TO_HIGHWAY_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_HIGHWAY_RIGHT;
  static constexpr Type TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT;
  static constexpr Type TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT;
  static constexpr Type TYPE_CONSOLIDATED_DIRECTIONS =
    TrafficSign_MainSign_Classification_Type_TYPE_CONSOLIDATED_DIRECTIONS;
  static constexpr Type TYPE_STREET_NAME =
    TrafficSign_MainSign_Classification_Type_TYPE_STREET_NAME;
  static constexpr Type TYPE_DIRECTION_PREANNOUNCEMENT =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT;
  static constexpr Type TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG;
  static constexpr Type TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES;
  static constexpr Type TYPE_HIGHWAY_ANNOUNCEMENT =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ANNOUNCEMENT;
  static constexpr Type TYPE_OTHER_ROAD_ANNOUNCEMENT =
    TrafficSign_MainSign_Classification_Type_TYPE_OTHER_ROAD_ANNOUNCEMENT;
  static constexpr Type TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP;
  static constexpr Type TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS;
  static constexpr Type TYPE_POLE_EXIT =
    TrafficSign_MainSign_Classification_Type_TYPE_POLE_EXIT;
  static constexpr Type TYPE_HIGHWAY_DISTANCE_BOARD =
    TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_DISTANCE_BOARD;
  static constexpr Type TYPE_DETOUR_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_LEFT;
  static constexpr Type TYPE_DETOUR_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_RIGHT;
  static constexpr Type TYPE_NUMBERED_DETOUR =
    TrafficSign_MainSign_Classification_Type_TYPE_NUMBERED_DETOUR;
  static constexpr Type TYPE_DETOUR_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_BEGIN;
  static constexpr Type TYPE_DETOUR_END =
    TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_END;
  static constexpr Type TYPE_DETOUR_ROUTING_BOARD =
    TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_ROUTING_BOARD;
  static constexpr Type TYPE_OPTIONAL_DETOUR =
    TrafficSign_MainSign_Classification_Type_TYPE_OPTIONAL_DETOUR;
  static constexpr Type TYPE_OPTIONAL_DETOUR_ROUTING =
    TrafficSign_MainSign_Classification_Type_TYPE_OPTIONAL_DETOUR_ROUTING;
  static constexpr Type TYPE_ROUTE_RECOMMENDATION =
    TrafficSign_MainSign_Classification_Type_TYPE_ROUTE_RECOMMENDATION;
  static constexpr Type TYPE_ROUTE_RECOMMENDATION_END =
    TrafficSign_MainSign_Classification_Type_TYPE_ROUTE_RECOMMENDATION_END;
  static constexpr Type TYPE_ANNOUNCE_LANE_TRANSITION_LEFT =
    TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_TRANSITION_LEFT;
  static constexpr Type TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT =
    TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT;
  static constexpr Type TYPE_ANNOUNCE_RIGHT_LANE_END =
    TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_RIGHT_LANE_END;
  static constexpr Type TYPE_ANNOUNCE_LEFT_LANE_END =
    TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LEFT_LANE_END;
  static constexpr Type TYPE_ANNOUNCE_RIGHT_LANE_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_RIGHT_LANE_BEGIN;
  static constexpr Type TYPE_ANNOUNCE_LEFT_LANE_BEGIN =
    TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LEFT_LANE_BEGIN;
  static constexpr Type TYPE_ANNOUNCE_LANE_CONSOLIDATION =
    TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_CONSOLIDATION;
  static constexpr Type TYPE_DETOUR_CITY_BLOCK =
    TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_CITY_BLOCK;
  static constexpr Type TYPE_GATE =
    TrafficSign_MainSign_Classification_Type_TYPE_GATE;
  static constexpr Type TYPE_POLE_WARNING =
    TrafficSign_MainSign_Classification_Type_TYPE_POLE_WARNING;
  static constexpr Type TYPE_TRAFFIC_CONE =
    TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_CONE;
  static constexpr Type TYPE_MOBILE_LANE_CLOSURE =
    TrafficSign_MainSign_Classification_Type_TYPE_MOBILE_LANE_CLOSURE;
  static constexpr Type TYPE_REFLECTOR_POST =
    TrafficSign_MainSign_Classification_Type_TYPE_REFLECTOR_POST;
  static constexpr Type TYPE_DIRECTIONAL_BOARD_WARNING =
    TrafficSign_MainSign_Classification_Type_TYPE_DIRECTIONAL_BOARD_WARNING;
  static constexpr Type TYPE_GUIDING_PLATE =
    TrafficSign_MainSign_Classification_Type_TYPE_GUIDING_PLATE;
  static constexpr Type TYPE_GUIDING_PLATE_WEDGES =
    TrafficSign_MainSign_Classification_Type_TYPE_GUIDING_PLATE_WEDGES;
  static constexpr Type TYPE_PARKING_HAZARD =
    TrafficSign_MainSign_Classification_Type_TYPE_PARKING_HAZARD;
  static constexpr Type TYPE_TRAFFIC_LIGHT_GREEN_ARROW =
    TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_LIGHT_GREEN_ARROW;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_MainSign_Classification_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TrafficSign_MainSign_Classification_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TrafficSign_MainSign_Classification_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TrafficSign_MainSign_Classification_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return TrafficSign_MainSign_Classification_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TrafficSign_MainSign_Classification_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return TrafficSign_MainSign_Classification_Type_Parse(name, value);
  }

  typedef TrafficSign_MainSign_Classification_DirectionScope DirectionScope;
  static constexpr DirectionScope DIRECTION_SCOPE_UNKNOWN =
    TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_UNKNOWN;
  static constexpr DirectionScope DIRECTION_SCOPE_OTHER =
    TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_OTHER;
  static constexpr DirectionScope DIRECTION_SCOPE_NO_DIRECTION =
    TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_NO_DIRECTION;
  static constexpr DirectionScope DIRECTION_SCOPE_LEFT =
    TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT;
  static constexpr DirectionScope DIRECTION_SCOPE_RIGHT =
    TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_RIGHT;
  static constexpr DirectionScope DIRECTION_SCOPE_LEFT_RIGHT =
    TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT_RIGHT;
  static inline bool DirectionScope_IsValid(int value) {
    return TrafficSign_MainSign_Classification_DirectionScope_IsValid(value);
  }
  static constexpr DirectionScope DirectionScope_MIN =
    TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MIN;
  static constexpr DirectionScope DirectionScope_MAX =
    TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MAX;
  static constexpr int DirectionScope_ARRAYSIZE =
    TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DirectionScope_descriptor() {
    return TrafficSign_MainSign_Classification_DirectionScope_descriptor();
  }
  template<typename T>
  static inline const std::string& DirectionScope_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DirectionScope>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DirectionScope_Name.");
    return TrafficSign_MainSign_Classification_DirectionScope_Name(enum_t_value);
  }
  static inline bool DirectionScope_Parse(const std::string& name,
      DirectionScope* value) {
    return TrafficSign_MainSign_Classification_DirectionScope_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedLaneIdFieldNumber = 5,
    kCountryFieldNumber = 8,
    kCountryRevisionFieldNumber = 9,
    kCodeFieldNumber = 10,
    kSubCodeFieldNumber = 11,
    kValueFieldNumber = 3,
    kVariabilityFieldNumber = 1,
    kTypeFieldNumber = 2,
    kDirectionScopeFieldNumber = 4,
    kVerticallyMirroredFieldNumber = 6,
    kIsOutOfServiceFieldNumber = 7,
  };
  // repeated .osi3.Identifier assigned_lane_id = 5;
  int assigned_lane_id_size() const;
  private:
  int _internal_assigned_lane_id_size() const;
  public:
  void clear_assigned_lane_id();
  ::osi3::Identifier* mutable_assigned_lane_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >*
      mutable_assigned_lane_id();
  private:
  const ::osi3::Identifier& _internal_assigned_lane_id(int index) const;
  ::osi3::Identifier* _internal_add_assigned_lane_id();
  public:
  const ::osi3::Identifier& assigned_lane_id(int index) const;
  ::osi3::Identifier* add_assigned_lane_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >&
      assigned_lane_id() const;

  // optional string country = 8;
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  void set_country(const std::string& value);
  void set_country(std::string&& value);
  void set_country(const char* value);
  void set_country(const char* value, size_t size);
  std::string* mutable_country();
  std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // optional string country_revision = 9;
  bool has_country_revision() const;
  private:
  bool _internal_has_country_revision() const;
  public:
  void clear_country_revision();
  const std::string& country_revision() const;
  void set_country_revision(const std::string& value);
  void set_country_revision(std::string&& value);
  void set_country_revision(const char* value);
  void set_country_revision(const char* value, size_t size);
  std::string* mutable_country_revision();
  std::string* release_country_revision();
  void set_allocated_country_revision(std::string* country_revision);
  private:
  const std::string& _internal_country_revision() const;
  void _internal_set_country_revision(const std::string& value);
  std::string* _internal_mutable_country_revision();
  public:

  // optional string code = 10;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional string sub_code = 11;
  bool has_sub_code() const;
  private:
  bool _internal_has_sub_code() const;
  public:
  void clear_sub_code();
  const std::string& sub_code() const;
  void set_sub_code(const std::string& value);
  void set_sub_code(std::string&& value);
  void set_sub_code(const char* value);
  void set_sub_code(const char* value, size_t size);
  std::string* mutable_sub_code();
  std::string* release_sub_code();
  void set_allocated_sub_code(std::string* sub_code);
  private:
  const std::string& _internal_sub_code() const;
  void _internal_set_sub_code(const std::string& value);
  std::string* _internal_mutable_sub_code();
  public:

  // optional .osi3.TrafficSignValue value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::osi3::TrafficSignValue& value() const;
  ::osi3::TrafficSignValue* release_value();
  ::osi3::TrafficSignValue* mutable_value();
  void set_allocated_value(::osi3::TrafficSignValue* value);
  private:
  const ::osi3::TrafficSignValue& _internal_value() const;
  ::osi3::TrafficSignValue* _internal_mutable_value();
  public:

  // optional .osi3.TrafficSign.Variability variability = 1;
  bool has_variability() const;
  private:
  bool _internal_has_variability() const;
  public:
  void clear_variability();
  ::osi3::TrafficSign_Variability variability() const;
  void set_variability(::osi3::TrafficSign_Variability value);
  private:
  ::osi3::TrafficSign_Variability _internal_variability() const;
  void _internal_set_variability(::osi3::TrafficSign_Variability value);
  public:

  // optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::osi3::TrafficSign_MainSign_Classification_Type type() const;
  void set_type(::osi3::TrafficSign_MainSign_Classification_Type value);
  private:
  ::osi3::TrafficSign_MainSign_Classification_Type _internal_type() const;
  void _internal_set_type(::osi3::TrafficSign_MainSign_Classification_Type value);
  public:

  // optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
  bool has_direction_scope() const;
  private:
  bool _internal_has_direction_scope() const;
  public:
  void clear_direction_scope();
  ::osi3::TrafficSign_MainSign_Classification_DirectionScope direction_scope() const;
  void set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value);
  private:
  ::osi3::TrafficSign_MainSign_Classification_DirectionScope _internal_direction_scope() const;
  void _internal_set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value);
  public:

  // optional bool vertically_mirrored = 6;
  bool has_vertically_mirrored() const;
  private:
  bool _internal_has_vertically_mirrored() const;
  public:
  void clear_vertically_mirrored();
  bool vertically_mirrored() const;
  void set_vertically_mirrored(bool value);
  private:
  bool _internal_vertically_mirrored() const;
  void _internal_set_vertically_mirrored(bool value);
  public:

  // optional bool is_out_of_service = 7;
  bool has_is_out_of_service() const;
  private:
  bool _internal_has_is_out_of_service() const;
  public:
  void clear_is_out_of_service();
  bool is_out_of_service() const;
  void set_is_out_of_service(bool value);
  private:
  bool _internal_is_out_of_service() const;
  void _internal_set_is_out_of_service(bool value);
  public:

  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.MainSign.Classification)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier > assigned_lane_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sub_code_;
  ::osi3::TrafficSignValue* value_;
  int variability_;
  int type_;
  int direction_scope_;
  bool vertically_mirrored_;
  bool is_out_of_service_;
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_MainSign :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.TrafficSign.MainSign) */ {
 public:
  TrafficSign_MainSign();
  virtual ~TrafficSign_MainSign();

  TrafficSign_MainSign(const TrafficSign_MainSign& from);
  TrafficSign_MainSign(TrafficSign_MainSign&& from) noexcept
    : TrafficSign_MainSign() {
    *this = ::std::move(from);
  }

  inline TrafficSign_MainSign& operator=(const TrafficSign_MainSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_MainSign& operator=(TrafficSign_MainSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSign_MainSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_MainSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_MainSign*>(
               &_TrafficSign_MainSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TrafficSign_MainSign& a, TrafficSign_MainSign& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_MainSign* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_MainSign* New() const final {
    return CreateMaybeMessage<TrafficSign_MainSign>(nullptr);
  }

  TrafficSign_MainSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_MainSign>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSign_MainSign& from);
  void MergeFrom(const TrafficSign_MainSign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_MainSign* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.TrafficSign.MainSign";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ftrafficsign_2eproto);
    return ::descriptor_table_osi_5ftrafficsign_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSign_MainSign_Classification Classification;

  // accessors -------------------------------------------------------

  enum : int {
    kModelReferenceFieldNumber = 3,
    kBaseFieldNumber = 1,
    kClassificationFieldNumber = 2,
  };
  // optional string model_reference = 3;
  bool has_model_reference() const;
  private:
  bool _internal_has_model_reference() const;
  public:
  void clear_model_reference();
  const std::string& model_reference() const;
  void set_model_reference(const std::string& value);
  void set_model_reference(std::string&& value);
  void set_model_reference(const char* value);
  void set_model_reference(const char* value, size_t size);
  std::string* mutable_model_reference();
  std::string* release_model_reference();
  void set_allocated_model_reference(std::string* model_reference);
  private:
  const std::string& _internal_model_reference() const;
  void _internal_set_model_reference(const std::string& value);
  std::string* _internal_mutable_model_reference();
  public:

  // optional .osi3.BaseStationary base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::osi3::BaseStationary& base() const;
  ::osi3::BaseStationary* release_base();
  ::osi3::BaseStationary* mutable_base();
  void set_allocated_base(::osi3::BaseStationary* base);
  private:
  const ::osi3::BaseStationary& _internal_base() const;
  ::osi3::BaseStationary* _internal_mutable_base();
  public:

  // optional .osi3.TrafficSign.MainSign.Classification classification = 2;
  bool has_classification() const;
  private:
  bool _internal_has_classification() const;
  public:
  void clear_classification();
  const ::osi3::TrafficSign_MainSign_Classification& classification() const;
  ::osi3::TrafficSign_MainSign_Classification* release_classification();
  ::osi3::TrafficSign_MainSign_Classification* mutable_classification();
  void set_allocated_classification(::osi3::TrafficSign_MainSign_Classification* classification);
  private:
  const ::osi3::TrafficSign_MainSign_Classification& _internal_classification() const;
  ::osi3::TrafficSign_MainSign_Classification* _internal_mutable_classification();
  public:

  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.MainSign)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_reference_;
  ::osi3::BaseStationary* base_;
  ::osi3::TrafficSign_MainSign_Classification* classification_;
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_SupplementarySign_Classification_Arrow :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.TrafficSign.SupplementarySign.Classification.Arrow) */ {
 public:
  TrafficSign_SupplementarySign_Classification_Arrow();
  virtual ~TrafficSign_SupplementarySign_Classification_Arrow();

  TrafficSign_SupplementarySign_Classification_Arrow(const TrafficSign_SupplementarySign_Classification_Arrow& from);
  TrafficSign_SupplementarySign_Classification_Arrow(TrafficSign_SupplementarySign_Classification_Arrow&& from) noexcept
    : TrafficSign_SupplementarySign_Classification_Arrow() {
    *this = ::std::move(from);
  }

  inline TrafficSign_SupplementarySign_Classification_Arrow& operator=(const TrafficSign_SupplementarySign_Classification_Arrow& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_SupplementarySign_Classification_Arrow& operator=(TrafficSign_SupplementarySign_Classification_Arrow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSign_SupplementarySign_Classification_Arrow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_SupplementarySign_Classification_Arrow* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySign_Classification_Arrow*>(
               &_TrafficSign_SupplementarySign_Classification_Arrow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TrafficSign_SupplementarySign_Classification_Arrow& a, TrafficSign_SupplementarySign_Classification_Arrow& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_SupplementarySign_Classification_Arrow* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_SupplementarySign_Classification_Arrow* New() const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySign_Classification_Arrow>(nullptr);
  }

  TrafficSign_SupplementarySign_Classification_Arrow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySign_Classification_Arrow>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSign_SupplementarySign_Classification_Arrow& from);
  void MergeFrom(const TrafficSign_SupplementarySign_Classification_Arrow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_SupplementarySign_Classification_Arrow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.TrafficSign.SupplementarySign.Classification.Arrow";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ftrafficsign_2eproto);
    return ::descriptor_table_osi_5ftrafficsign_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSign_SupplementarySign_Classification_Arrow_Direction Direction;
  static constexpr Direction DIRECTION_UNKNOWN =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_UNKNOWN;
  static constexpr Direction DIRECTION_OTHER =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_OTHER;
  static constexpr Direction DIRECTION_NO_DIRECTION =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_NO_DIRECTION;
  static constexpr Direction DIRECTION_DIRECT_0_DEG =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_0_DEG;
  static constexpr Direction DIRECTION_DIRECT_45_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_45_DEG_RIGHT;
  static constexpr Direction DIRECTION_DIRECT_45_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_45_DEG_LEFT;
  static constexpr Direction DIRECTION_DIRECT_90_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_DIRECT_90_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_90_DEG_LEFT;
  static constexpr Direction DIRECTION_DIRECT_135_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_135_DEG_RIGHT;
  static constexpr Direction DIRECTION_DIRECT_135_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_135_DEG_LEFT;
  static constexpr Direction DIRECTION_DIRECT_180_DEG =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_180_DEG;
  static constexpr Direction DIRECTION_TURN_45_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_45_DEG_RIGHT;
  static constexpr Direction DIRECTION_TURN_45_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_45_DEG_LEFT;
  static constexpr Direction DIRECTION_TURN_90_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_TURN_90_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_90_DEG_LEFT;
  static constexpr Direction DIRECTION_TURN_135_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_135_DEG_RIGHT;
  static constexpr Direction DIRECTION_TURN_135_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_135_DEG_LEFT;
  static constexpr Direction DIRECTION_TURN_180_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_180_DEG_RIGHT;
  static constexpr Direction DIRECTION_TURN_180_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_180_DEG_LEFT;
  static constexpr Direction DIRECTION_CIRCLE_0_DEG =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_0_DEG;
  static constexpr Direction DIRECTION_CIRCLE_45_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_45_DEG_RIGHT;
  static constexpr Direction DIRECTION_CIRCLE_45_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_45_DEG_LEFT;
  static constexpr Direction DIRECTION_CIRCLE_90_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_CIRCLE_90_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_90_DEG_LEFT;
  static constexpr Direction DIRECTION_CIRCLE_135_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_135_DEG_RIGHT;
  static constexpr Direction DIRECTION_CIRCLE_135_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_135_DEG_LEFT;
  static constexpr Direction DIRECTION_CIRCLE_180_DEG =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_180_DEG;
  static constexpr Direction DIRECTION_KEEP_LEFT_TO_TURN_0_DEG =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_TO_TURN_0_DEG;
  static constexpr Direction DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG;
  static constexpr Direction DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT;
  static constexpr Direction DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT;
  static inline bool Direction_IsValid(int value) {
    return TrafficSign_SupplementarySign_Classification_Arrow_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return TrafficSign_SupplementarySign_Classification_Arrow_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(const std::string& name,
      Direction* value) {
    return TrafficSign_SupplementarySign_Classification_Arrow_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLaneIdFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // repeated .osi3.Identifier lane_id = 1;
  int lane_id_size() const;
  private:
  int _internal_lane_id_size() const;
  public:
  void clear_lane_id();
  ::osi3::Identifier* mutable_lane_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >*
      mutable_lane_id();
  private:
  const ::osi3::Identifier& _internal_lane_id(int index) const;
  ::osi3::Identifier* _internal_add_lane_id();
  public:
  const ::osi3::Identifier& lane_id(int index) const;
  ::osi3::Identifier* add_lane_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >&
      lane_id() const;

  // repeated .osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction direction = 2;
  int direction_size() const;
  private:
  int _internal_direction_size() const;
  public:
  void clear_direction();
  private:
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction _internal_direction(int index) const;
  void _internal_add_direction(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_direction();
  public:
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction direction(int index) const;
  void set_direction(int index, ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value);
  void add_direction(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& direction() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_direction();

  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.SupplementarySign.Classification.Arrow)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier > lane_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> direction_;
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_SupplementarySign_Classification :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.TrafficSign.SupplementarySign.Classification) */ {
 public:
  TrafficSign_SupplementarySign_Classification();
  virtual ~TrafficSign_SupplementarySign_Classification();

  TrafficSign_SupplementarySign_Classification(const TrafficSign_SupplementarySign_Classification& from);
  TrafficSign_SupplementarySign_Classification(TrafficSign_SupplementarySign_Classification&& from) noexcept
    : TrafficSign_SupplementarySign_Classification() {
    *this = ::std::move(from);
  }

  inline TrafficSign_SupplementarySign_Classification& operator=(const TrafficSign_SupplementarySign_Classification& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_SupplementarySign_Classification& operator=(TrafficSign_SupplementarySign_Classification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSign_SupplementarySign_Classification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_SupplementarySign_Classification* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySign_Classification*>(
               &_TrafficSign_SupplementarySign_Classification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrafficSign_SupplementarySign_Classification& a, TrafficSign_SupplementarySign_Classification& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_SupplementarySign_Classification* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_SupplementarySign_Classification* New() const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySign_Classification>(nullptr);
  }

  TrafficSign_SupplementarySign_Classification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySign_Classification>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSign_SupplementarySign_Classification& from);
  void MergeFrom(const TrafficSign_SupplementarySign_Classification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_SupplementarySign_Classification* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.TrafficSign.SupplementarySign.Classification";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ftrafficsign_2eproto);
    return ::descriptor_table_osi_5ftrafficsign_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSign_SupplementarySign_Classification_Arrow Arrow;

  typedef TrafficSign_SupplementarySign_Classification_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_OTHER =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_OTHER;
  static constexpr Type TYPE_NO_SIGN =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_NO_SIGN;
  static constexpr Type TYPE_TEXT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_TEXT;
  static constexpr Type TYPE_SPACE =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_SPACE;
  static constexpr Type TYPE_TIME =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_TIME;
  static constexpr Type TYPE_ARROW =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_ARROW;
  static constexpr Type TYPE_CONSTRAINED_TO =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_CONSTRAINED_TO;
  static constexpr Type TYPE_EXCEPT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_EXCEPT;
  static constexpr Type TYPE_VALID_FOR_DISTANCE =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_VALID_FOR_DISTANCE;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY;
  static constexpr Type TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS;
  static constexpr Type TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY;
  static constexpr Type TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY;
  static constexpr Type TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT;
  static constexpr Type TYPE_VALID_IN_DISTANCE =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_VALID_IN_DISTANCE;
  static constexpr Type TYPE_STOP_IN =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_STOP_IN;
  static constexpr Type TYPE_LEFT_ARROW =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_LEFT_ARROW;
  static constexpr Type TYPE_LEFT_BEND_ARROW =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_LEFT_BEND_ARROW;
  static constexpr Type TYPE_RIGHT_ARROW =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_RIGHT_ARROW;
  static constexpr Type TYPE_RIGHT_BEND_ARROW =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_RIGHT_BEND_ARROW;
  static constexpr Type TYPE_ACCIDENT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_ACCIDENT;
  static constexpr Type TYPE_SNOW =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_SNOW;
  static constexpr Type TYPE_FOG =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_FOG;
  static constexpr Type TYPE_ROLLING_HIGHWAY_INFORMATION =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_ROLLING_HIGHWAY_INFORMATION;
  static constexpr Type TYPE_SERVICES =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_SERVICES;
  static constexpr Type TYPE_TIME_RANGE =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_TIME_RANGE;
  static constexpr Type TYPE_PARKING_DISC_TIME_RESTRICTION =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PARKING_DISC_TIME_RESTRICTION;
  static constexpr Type TYPE_WEIGHT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_WEIGHT;
  static constexpr Type TYPE_WET =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_WET;
  static constexpr Type TYPE_PARKING_CONSTRAINT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_PARKING_CONSTRAINT;
  static constexpr Type TYPE_NO_WAITING_SIDE_STRIPES =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_NO_WAITING_SIDE_STRIPES;
  static constexpr Type TYPE_RAIN =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_RAIN;
  static constexpr Type TYPE_SNOW_RAIN =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_SNOW_RAIN;
  static constexpr Type TYPE_NIGHT =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_NIGHT;
  static constexpr Type TYPE_STOP_4_WAY =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_STOP_4_WAY;
  static constexpr Type TYPE_TRUCK =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_TRUCK;
  static constexpr Type TYPE_TRACTORS_MAY_BE_PASSED =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_TRACTORS_MAY_BE_PASSED;
  static constexpr Type TYPE_HAZARDOUS =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_HAZARDOUS;
  static constexpr Type TYPE_TRAILER =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_TRAILER;
  static constexpr Type TYPE_ZONE =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_ZONE;
  static constexpr Type TYPE_MOTORCYCLE =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_MOTORCYCLE;
  static constexpr Type TYPE_MOTORCYCLE_ALLOWED =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_MOTORCYCLE_ALLOWED;
  static constexpr Type TYPE_CAR =
    TrafficSign_SupplementarySign_Classification_Type_TYPE_CAR;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_SupplementarySign_Classification_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TrafficSign_SupplementarySign_Classification_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TrafficSign_SupplementarySign_Classification_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TrafficSign_SupplementarySign_Classification_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return TrafficSign_SupplementarySign_Classification_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TrafficSign_SupplementarySign_Classification_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return TrafficSign_SupplementarySign_Classification_Type_Parse(name, value);
  }

  typedef TrafficSign_SupplementarySign_Classification_Actor Actor;
  static constexpr Actor ACTOR_UNKNOWN =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_UNKNOWN;
  static constexpr Actor ACTOR_OTHER =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_OTHER;
  static constexpr Actor ACTOR_NO_ACTOR =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_NO_ACTOR;
  static constexpr Actor ACTOR_AGRICULTURAL_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_AGRICULTURAL_VEHICLES;
  static constexpr Actor ACTOR_BICYCLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_BICYCLES;
  static constexpr Actor ACTOR_BUSES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_BUSES;
  static constexpr Actor ACTOR_CAMPERS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CAMPERS;
  static constexpr Actor ACTOR_CARAVANS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARAVANS;
  static constexpr Actor ACTOR_CARS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS;
  static constexpr Actor ACTOR_CARS_WITH_CARAVANS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS_WITH_CARAVANS;
  static constexpr Actor ACTOR_CARS_WITH_TRAILERS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS_WITH_TRAILERS;
  static constexpr Actor ACTOR_CATTLE =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CATTLE;
  static constexpr Actor ACTOR_CHILDREN =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CHILDREN;
  static constexpr Actor ACTOR_CONSTRUCTION_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CONSTRUCTION_VEHICLES;
  static constexpr Actor ACTOR_DELIVERY_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_DELIVERY_VEHICLES;
  static constexpr Actor ACTOR_DISABLED_PERSONS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_DISABLED_PERSONS;
  static constexpr Actor ACTOR_EBIKES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_EBIKES;
  static constexpr Actor ACTOR_ELECTRIC_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_ELECTRIC_VEHICLES;
  static constexpr Actor ACTOR_EMERGENCY_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_EMERGENCY_VEHICLES;
  static constexpr Actor ACTOR_FERRY_USERS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_FERRY_USERS;
  static constexpr Actor ACTOR_FORESTRY_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_FORESTRY_VEHICLES;
  static constexpr Actor ACTOR_HAZARDOUS_GOODS_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HAZARDOUS_GOODS_VEHICLES;
  static constexpr Actor ACTOR_HORSE_CARRIAGES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HORSE_CARRIAGES;
  static constexpr Actor ACTOR_HORSE_RIDERS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HORSE_RIDERS;
  static constexpr Actor ACTOR_INLINE_SKATERS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_INLINE_SKATERS;
  static constexpr Actor ACTOR_MEDICAL_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MEDICAL_VEHICLES;
  static constexpr Actor ACTOR_MILITARY_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MILITARY_VEHICLES;
  static constexpr Actor ACTOR_MOPEDS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOPEDS;
  static constexpr Actor ACTOR_MOTORCYCLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOTORCYCLES;
  static constexpr Actor ACTOR_MOTORIZED_MULTITRACK_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOTORIZED_MULTITRACK_VEHICLES;
  static constexpr Actor ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES;
  static constexpr Actor ACTOR_PEDESTRIANS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_PEDESTRIANS;
  static constexpr Actor ACTOR_PUBLIC_TRANSPORT_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_PUBLIC_TRANSPORT_VEHICLES;
  static constexpr Actor ACTOR_RAILROAD_TRAFFIC =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_RAILROAD_TRAFFIC;
  static constexpr Actor ACTOR_RESIDENTS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_RESIDENTS;
  static constexpr Actor ACTOR_SLURRY_TRANSPORT =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_SLURRY_TRANSPORT;
  static constexpr Actor ACTOR_TAXIS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TAXIS;
  static constexpr Actor ACTOR_TRACTORS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRACTORS;
  static constexpr Actor ACTOR_TRAILERS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRAILERS;
  static constexpr Actor ACTOR_TRAMS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRAMS;
  static constexpr Actor ACTOR_TRUCKS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS;
  static constexpr Actor ACTOR_TRUCKS_WITH_SEMITRAILERS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS_WITH_SEMITRAILERS;
  static constexpr Actor ACTOR_TRUCKS_WITH_TRAILERS =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS_WITH_TRAILERS;
  static constexpr Actor ACTOR_VEHICLES_WITH_GREEN_BADGES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_GREEN_BADGES;
  static constexpr Actor ACTOR_VEHICLES_WITH_RED_BADGES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_RED_BADGES;
  static constexpr Actor ACTOR_VEHICLES_WITH_YELLOW_BADGES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_YELLOW_BADGES;
  static constexpr Actor ACTOR_WATER_POLLUTANT_VEHICLES =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WATER_POLLUTANT_VEHICLES;
  static constexpr Actor ACTOR_WINTER_SPORTSPEOPLE =
    TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WINTER_SPORTSPEOPLE;
  static inline bool Actor_IsValid(int value) {
    return TrafficSign_SupplementarySign_Classification_Actor_IsValid(value);
  }
  static constexpr Actor Actor_MIN =
    TrafficSign_SupplementarySign_Classification_Actor_Actor_MIN;
  static constexpr Actor Actor_MAX =
    TrafficSign_SupplementarySign_Classification_Actor_Actor_MAX;
  static constexpr int Actor_ARRAYSIZE =
    TrafficSign_SupplementarySign_Classification_Actor_Actor_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Actor_descriptor() {
    return TrafficSign_SupplementarySign_Classification_Actor_descriptor();
  }
  template<typename T>
  static inline const std::string& Actor_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Actor>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Actor_Name.");
    return TrafficSign_SupplementarySign_Classification_Actor_Name(enum_t_value);
  }
  static inline bool Actor_Parse(const std::string& name,
      Actor* value) {
    return TrafficSign_SupplementarySign_Classification_Actor_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kAssignedLaneIdFieldNumber = 4,
    kActorFieldNumber = 5,
    kArrowFieldNumber = 6,
    kCountryFieldNumber = 8,
    kCountryRevisionFieldNumber = 9,
    kCodeFieldNumber = 10,
    kSubCodeFieldNumber = 11,
    kVariabilityFieldNumber = 1,
    kTypeFieldNumber = 2,
    kIsOutOfServiceFieldNumber = 7,
  };
  // repeated .osi3.TrafficSignValue value = 3;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::osi3::TrafficSignValue* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSignValue >*
      mutable_value();
  private:
  const ::osi3::TrafficSignValue& _internal_value(int index) const;
  ::osi3::TrafficSignValue* _internal_add_value();
  public:
  const ::osi3::TrafficSignValue& value(int index) const;
  ::osi3::TrafficSignValue* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSignValue >&
      value() const;

  // repeated .osi3.Identifier assigned_lane_id = 4;
  int assigned_lane_id_size() const;
  private:
  int _internal_assigned_lane_id_size() const;
  public:
  void clear_assigned_lane_id();
  ::osi3::Identifier* mutable_assigned_lane_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >*
      mutable_assigned_lane_id();
  private:
  const ::osi3::Identifier& _internal_assigned_lane_id(int index) const;
  ::osi3::Identifier* _internal_add_assigned_lane_id();
  public:
  const ::osi3::Identifier& assigned_lane_id(int index) const;
  ::osi3::Identifier* add_assigned_lane_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >&
      assigned_lane_id() const;

  // repeated .osi3.TrafficSign.SupplementarySign.Classification.Actor actor = 5;
  int actor_size() const;
  private:
  int _internal_actor_size() const;
  public:
  void clear_actor();
  private:
  ::osi3::TrafficSign_SupplementarySign_Classification_Actor _internal_actor(int index) const;
  void _internal_add_actor(::osi3::TrafficSign_SupplementarySign_Classification_Actor value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_actor();
  public:
  ::osi3::TrafficSign_SupplementarySign_Classification_Actor actor(int index) const;
  void set_actor(int index, ::osi3::TrafficSign_SupplementarySign_Classification_Actor value);
  void add_actor(::osi3::TrafficSign_SupplementarySign_Classification_Actor value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& actor() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_actor();

  // repeated .osi3.TrafficSign.SupplementarySign.Classification.Arrow arrow = 6;
  int arrow_size() const;
  private:
  int _internal_arrow_size() const;
  public:
  void clear_arrow();
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* mutable_arrow(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow >*
      mutable_arrow();
  private:
  const ::osi3::TrafficSign_SupplementarySign_Classification_Arrow& _internal_arrow(int index) const;
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* _internal_add_arrow();
  public:
  const ::osi3::TrafficSign_SupplementarySign_Classification_Arrow& arrow(int index) const;
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* add_arrow();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow >&
      arrow() const;

  // optional string country = 8;
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  void set_country(const std::string& value);
  void set_country(std::string&& value);
  void set_country(const char* value);
  void set_country(const char* value, size_t size);
  std::string* mutable_country();
  std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // optional string country_revision = 9;
  bool has_country_revision() const;
  private:
  bool _internal_has_country_revision() const;
  public:
  void clear_country_revision();
  const std::string& country_revision() const;
  void set_country_revision(const std::string& value);
  void set_country_revision(std::string&& value);
  void set_country_revision(const char* value);
  void set_country_revision(const char* value, size_t size);
  std::string* mutable_country_revision();
  std::string* release_country_revision();
  void set_allocated_country_revision(std::string* country_revision);
  private:
  const std::string& _internal_country_revision() const;
  void _internal_set_country_revision(const std::string& value);
  std::string* _internal_mutable_country_revision();
  public:

  // optional string code = 10;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional string sub_code = 11;
  bool has_sub_code() const;
  private:
  bool _internal_has_sub_code() const;
  public:
  void clear_sub_code();
  const std::string& sub_code() const;
  void set_sub_code(const std::string& value);
  void set_sub_code(std::string&& value);
  void set_sub_code(const char* value);
  void set_sub_code(const char* value, size_t size);
  std::string* mutable_sub_code();
  std::string* release_sub_code();
  void set_allocated_sub_code(std::string* sub_code);
  private:
  const std::string& _internal_sub_code() const;
  void _internal_set_sub_code(const std::string& value);
  std::string* _internal_mutable_sub_code();
  public:

  // optional .osi3.TrafficSign.Variability variability = 1;
  bool has_variability() const;
  private:
  bool _internal_has_variability() const;
  public:
  void clear_variability();
  ::osi3::TrafficSign_Variability variability() const;
  void set_variability(::osi3::TrafficSign_Variability value);
  private:
  ::osi3::TrafficSign_Variability _internal_variability() const;
  void _internal_set_variability(::osi3::TrafficSign_Variability value);
  public:

  // optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::osi3::TrafficSign_SupplementarySign_Classification_Type type() const;
  void set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value);
  private:
  ::osi3::TrafficSign_SupplementarySign_Classification_Type _internal_type() const;
  void _internal_set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value);
  public:

  // optional bool is_out_of_service = 7;
  bool has_is_out_of_service() const;
  private:
  bool _internal_has_is_out_of_service() const;
  public:
  void clear_is_out_of_service();
  bool is_out_of_service() const;
  void set_is_out_of_service(bool value);
  private:
  bool _internal_is_out_of_service() const;
  void _internal_set_is_out_of_service(bool value);
  public:

  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.SupplementarySign.Classification)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSignValue > value_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier > assigned_lane_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> actor_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow > arrow_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sub_code_;
  int variability_;
  int type_;
  bool is_out_of_service_;
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_SupplementarySign :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.TrafficSign.SupplementarySign) */ {
 public:
  TrafficSign_SupplementarySign();
  virtual ~TrafficSign_SupplementarySign();

  TrafficSign_SupplementarySign(const TrafficSign_SupplementarySign& from);
  TrafficSign_SupplementarySign(TrafficSign_SupplementarySign&& from) noexcept
    : TrafficSign_SupplementarySign() {
    *this = ::std::move(from);
  }

  inline TrafficSign_SupplementarySign& operator=(const TrafficSign_SupplementarySign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_SupplementarySign& operator=(TrafficSign_SupplementarySign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSign_SupplementarySign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_SupplementarySign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySign*>(
               &_TrafficSign_SupplementarySign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TrafficSign_SupplementarySign& a, TrafficSign_SupplementarySign& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_SupplementarySign* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_SupplementarySign* New() const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySign>(nullptr);
  }

  TrafficSign_SupplementarySign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySign>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSign_SupplementarySign& from);
  void MergeFrom(const TrafficSign_SupplementarySign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_SupplementarySign* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.TrafficSign.SupplementarySign";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ftrafficsign_2eproto);
    return ::descriptor_table_osi_5ftrafficsign_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSign_SupplementarySign_Classification Classification;

  // accessors -------------------------------------------------------

  enum : int {
    kModelReferenceFieldNumber = 3,
    kBaseFieldNumber = 1,
    kClassificationFieldNumber = 2,
  };
  // optional string model_reference = 3;
  bool has_model_reference() const;
  private:
  bool _internal_has_model_reference() const;
  public:
  void clear_model_reference();
  const std::string& model_reference() const;
  void set_model_reference(const std::string& value);
  void set_model_reference(std::string&& value);
  void set_model_reference(const char* value);
  void set_model_reference(const char* value, size_t size);
  std::string* mutable_model_reference();
  std::string* release_model_reference();
  void set_allocated_model_reference(std::string* model_reference);
  private:
  const std::string& _internal_model_reference() const;
  void _internal_set_model_reference(const std::string& value);
  std::string* _internal_mutable_model_reference();
  public:

  // optional .osi3.BaseStationary base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::osi3::BaseStationary& base() const;
  ::osi3::BaseStationary* release_base();
  ::osi3::BaseStationary* mutable_base();
  void set_allocated_base(::osi3::BaseStationary* base);
  private:
  const ::osi3::BaseStationary& _internal_base() const;
  ::osi3::BaseStationary* _internal_mutable_base();
  public:

  // optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
  bool has_classification() const;
  private:
  bool _internal_has_classification() const;
  public:
  void clear_classification();
  const ::osi3::TrafficSign_SupplementarySign_Classification& classification() const;
  ::osi3::TrafficSign_SupplementarySign_Classification* release_classification();
  ::osi3::TrafficSign_SupplementarySign_Classification* mutable_classification();
  void set_allocated_classification(::osi3::TrafficSign_SupplementarySign_Classification* classification);
  private:
  const ::osi3::TrafficSign_SupplementarySign_Classification& _internal_classification() const;
  ::osi3::TrafficSign_SupplementarySign_Classification* _internal_mutable_classification();
  public:

  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.SupplementarySign)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_reference_;
  ::osi3::BaseStationary* base_;
  ::osi3::TrafficSign_SupplementarySign_Classification* classification_;
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.TrafficSign) */ {
 public:
  TrafficSign();
  virtual ~TrafficSign();

  TrafficSign(const TrafficSign& from);
  TrafficSign(TrafficSign&& from) noexcept
    : TrafficSign() {
    *this = ::std::move(from);
  }

  inline TrafficSign& operator=(const TrafficSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign& operator=(TrafficSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign*>(
               &_TrafficSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TrafficSign& a, TrafficSign& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign* New() const final {
    return CreateMaybeMessage<TrafficSign>(nullptr);
  }

  TrafficSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficSign& from);
  void MergeFrom(const TrafficSign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.TrafficSign";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ftrafficsign_2eproto);
    return ::descriptor_table_osi_5ftrafficsign_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficSign_MainSign MainSign;
  typedef TrafficSign_SupplementarySign SupplementarySign;

  typedef TrafficSign_Variability Variability;
  static constexpr Variability VARIABILITY_UNKNOWN =
    TrafficSign_Variability_VARIABILITY_UNKNOWN;
  static constexpr Variability VARIABILITY_OTHER =
    TrafficSign_Variability_VARIABILITY_OTHER;
  static constexpr Variability VARIABILITY_FIXED =
    TrafficSign_Variability_VARIABILITY_FIXED;
  static constexpr Variability VARIABILITY_VARIABLE =
    TrafficSign_Variability_VARIABILITY_VARIABLE;
  static inline bool Variability_IsValid(int value) {
    return TrafficSign_Variability_IsValid(value);
  }
  static constexpr Variability Variability_MIN =
    TrafficSign_Variability_Variability_MIN;
  static constexpr Variability Variability_MAX =
    TrafficSign_Variability_Variability_MAX;
  static constexpr int Variability_ARRAYSIZE =
    TrafficSign_Variability_Variability_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Variability_descriptor() {
    return TrafficSign_Variability_descriptor();
  }
  template<typename T>
  static inline const std::string& Variability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Variability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Variability_Name.");
    return TrafficSign_Variability_Name(enum_t_value);
  }
  static inline bool Variability_Parse(const std::string& name,
      Variability* value) {
    return TrafficSign_Variability_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSupplementarySignFieldNumber = 3,
    kSourceReferenceFieldNumber = 4,
    kIdFieldNumber = 1,
    kMainSignFieldNumber = 2,
  };
  // repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
  int supplementary_sign_size() const;
  private:
  int _internal_supplementary_sign_size() const;
  public:
  void clear_supplementary_sign();
  ::osi3::TrafficSign_SupplementarySign* mutable_supplementary_sign(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign >*
      mutable_supplementary_sign();
  private:
  const ::osi3::TrafficSign_SupplementarySign& _internal_supplementary_sign(int index) const;
  ::osi3::TrafficSign_SupplementarySign* _internal_add_supplementary_sign();
  public:
  const ::osi3::TrafficSign_SupplementarySign& supplementary_sign(int index) const;
  ::osi3::TrafficSign_SupplementarySign* add_supplementary_sign();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign >&
      supplementary_sign() const;

  // repeated .osi3.ExternalReference source_reference = 4;
  int source_reference_size() const;
  private:
  int _internal_source_reference_size() const;
  public:
  void clear_source_reference();
  ::osi3::ExternalReference* mutable_source_reference(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::ExternalReference >*
      mutable_source_reference();
  private:
  const ::osi3::ExternalReference& _internal_source_reference(int index) const;
  ::osi3::ExternalReference* _internal_add_source_reference();
  public:
  const ::osi3::ExternalReference& source_reference(int index) const;
  ::osi3::ExternalReference* add_source_reference();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::ExternalReference >&
      source_reference() const;

  // optional .osi3.Identifier id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::osi3::Identifier& id() const;
  ::osi3::Identifier* release_id();
  ::osi3::Identifier* mutable_id();
  void set_allocated_id(::osi3::Identifier* id);
  private:
  const ::osi3::Identifier& _internal_id() const;
  ::osi3::Identifier* _internal_mutable_id();
  public:

  // optional .osi3.TrafficSign.MainSign main_sign = 2;
  bool has_main_sign() const;
  private:
  bool _internal_has_main_sign() const;
  public:
  void clear_main_sign();
  const ::osi3::TrafficSign_MainSign& main_sign() const;
  ::osi3::TrafficSign_MainSign* release_main_sign();
  ::osi3::TrafficSign_MainSign* mutable_main_sign();
  void set_allocated_main_sign(::osi3::TrafficSign_MainSign* main_sign);
  private:
  const ::osi3::TrafficSign_MainSign& _internal_main_sign() const;
  ::osi3::TrafficSign_MainSign* _internal_mutable_main_sign();
  public:

  // @@protoc_insertion_point(class_scope:osi3.TrafficSign)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign > supplementary_sign_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::ExternalReference > source_reference_;
  ::osi3::Identifier* id_;
  ::osi3::TrafficSign_MainSign* main_sign_;
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TrafficSignValue

// optional double value = 1;
inline bool TrafficSignValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficSignValue::has_value() const {
  return _internal_has_value();
}
inline void TrafficSignValue::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TrafficSignValue::_internal_value() const {
  return value_;
}
inline double TrafficSignValue::value() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSignValue.value)
  return _internal_value();
}
inline void TrafficSignValue::_internal_set_value(double value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void TrafficSignValue::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSignValue.value)
}

// optional .osi3.TrafficSignValue.Unit value_unit = 2;
inline bool TrafficSignValue::_internal_has_value_unit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficSignValue::has_value_unit() const {
  return _internal_has_value_unit();
}
inline void TrafficSignValue::clear_value_unit() {
  value_unit_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::osi3::TrafficSignValue_Unit TrafficSignValue::_internal_value_unit() const {
  return static_cast< ::osi3::TrafficSignValue_Unit >(value_unit_);
}
inline ::osi3::TrafficSignValue_Unit TrafficSignValue::value_unit() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSignValue.value_unit)
  return _internal_value_unit();
}
inline void TrafficSignValue::_internal_set_value_unit(::osi3::TrafficSignValue_Unit value) {
  assert(::osi3::TrafficSignValue_Unit_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  value_unit_ = value;
}
inline void TrafficSignValue::set_value_unit(::osi3::TrafficSignValue_Unit value) {
  _internal_set_value_unit(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSignValue.value_unit)
}

// optional string text = 3;
inline bool TrafficSignValue::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficSignValue::has_text() const {
  return _internal_has_text();
}
inline void TrafficSignValue::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSignValue::text() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSignValue.text)
  return _internal_text();
}
inline void TrafficSignValue::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSignValue.text)
}
inline std::string* TrafficSignValue::mutable_text() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSignValue.text)
  return _internal_mutable_text();
}
inline const std::string& TrafficSignValue::_internal_text() const {
  return text_.GetNoArena();
}
inline void TrafficSignValue::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSignValue::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSignValue.text)
}
inline void TrafficSignValue::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSignValue.text)
}
inline void TrafficSignValue::set_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSignValue.text)
}
inline std::string* TrafficSignValue::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSignValue::release_text() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSignValue.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSignValue::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSignValue.text)
}

// -------------------------------------------------------------------

// TrafficSign_MainSign_Classification

// optional .osi3.TrafficSign.Variability variability = 1;
inline bool TrafficSign_MainSign_Classification::_internal_has_variability() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_variability() const {
  return _internal_has_variability();
}
inline void TrafficSign_MainSign_Classification::clear_variability() {
  variability_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::osi3::TrafficSign_Variability TrafficSign_MainSign_Classification::_internal_variability() const {
  return static_cast< ::osi3::TrafficSign_Variability >(variability_);
}
inline ::osi3::TrafficSign_Variability TrafficSign_MainSign_Classification::variability() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.variability)
  return _internal_variability();
}
inline void TrafficSign_MainSign_Classification::_internal_set_variability(::osi3::TrafficSign_Variability value) {
  assert(::osi3::TrafficSign_Variability_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  variability_ = value;
}
inline void TrafficSign_MainSign_Classification::set_variability(::osi3::TrafficSign_Variability value) {
  _internal_set_variability(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.variability)
}

// optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
inline bool TrafficSign_MainSign_Classification::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_type() const {
  return _internal_has_type();
}
inline void TrafficSign_MainSign_Classification::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::osi3::TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::_internal_type() const {
  return static_cast< ::osi3::TrafficSign_MainSign_Classification_Type >(type_);
}
inline ::osi3::TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::type() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.type)
  return _internal_type();
}
inline void TrafficSign_MainSign_Classification::_internal_set_type(::osi3::TrafficSign_MainSign_Classification_Type value) {
  assert(::osi3::TrafficSign_MainSign_Classification_Type_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
}
inline void TrafficSign_MainSign_Classification::set_type(::osi3::TrafficSign_MainSign_Classification_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.type)
}

// optional .osi3.TrafficSignValue value = 3;
inline bool TrafficSign_MainSign_Classification::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_value() const {
  return _internal_has_value();
}
inline void TrafficSign_MainSign_Classification::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::osi3::TrafficSignValue& TrafficSign_MainSign_Classification::_internal_value() const {
  const ::osi3::TrafficSignValue* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::TrafficSignValue*>(
      &::osi3::_TrafficSignValue_default_instance_);
}
inline const ::osi3::TrafficSignValue& TrafficSign_MainSign_Classification::value() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.value)
  return _internal_value();
}
inline ::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::release_value() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.value)
  _has_bits_[0] &= ~0x00000010u;
  ::osi3::TrafficSignValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000010u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::TrafficSignValue>(GetArenaNoVirtual());
    value_ = p;
  }
  return value_;
}
inline ::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::mutable_value() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.value)
  return _internal_mutable_value();
}
inline void TrafficSign_MainSign_Classification::set_allocated_value(::osi3::TrafficSignValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.value)
}

// optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
inline bool TrafficSign_MainSign_Classification::_internal_has_direction_scope() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_direction_scope() const {
  return _internal_has_direction_scope();
}
inline void TrafficSign_MainSign_Classification::clear_direction_scope() {
  direction_scope_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::osi3::TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::_internal_direction_scope() const {
  return static_cast< ::osi3::TrafficSign_MainSign_Classification_DirectionScope >(direction_scope_);
}
inline ::osi3::TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::direction_scope() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.direction_scope)
  return _internal_direction_scope();
}
inline void TrafficSign_MainSign_Classification::_internal_set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value) {
  assert(::osi3::TrafficSign_MainSign_Classification_DirectionScope_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  direction_scope_ = value;
}
inline void TrafficSign_MainSign_Classification::set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value) {
  _internal_set_direction_scope(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.direction_scope)
}

// repeated .osi3.Identifier assigned_lane_id = 5;
inline int TrafficSign_MainSign_Classification::_internal_assigned_lane_id_size() const {
  return assigned_lane_id_.size();
}
inline int TrafficSign_MainSign_Classification::assigned_lane_id_size() const {
  return _internal_assigned_lane_id_size();
}
inline ::osi3::Identifier* TrafficSign_MainSign_Classification::mutable_assigned_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return assigned_lane_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >*
TrafficSign_MainSign_Classification::mutable_assigned_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return &assigned_lane_id_;
}
inline const ::osi3::Identifier& TrafficSign_MainSign_Classification::_internal_assigned_lane_id(int index) const {
  return assigned_lane_id_.Get(index);
}
inline const ::osi3::Identifier& TrafficSign_MainSign_Classification::assigned_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return _internal_assigned_lane_id(index);
}
inline ::osi3::Identifier* TrafficSign_MainSign_Classification::_internal_add_assigned_lane_id() {
  return assigned_lane_id_.Add();
}
inline ::osi3::Identifier* TrafficSign_MainSign_Classification::add_assigned_lane_id() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return _internal_add_assigned_lane_id();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >&
TrafficSign_MainSign_Classification::assigned_lane_id() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return assigned_lane_id_;
}

// optional bool vertically_mirrored = 6;
inline bool TrafficSign_MainSign_Classification::_internal_has_vertically_mirrored() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_vertically_mirrored() const {
  return _internal_has_vertically_mirrored();
}
inline void TrafficSign_MainSign_Classification::clear_vertically_mirrored() {
  vertically_mirrored_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool TrafficSign_MainSign_Classification::_internal_vertically_mirrored() const {
  return vertically_mirrored_;
}
inline bool TrafficSign_MainSign_Classification::vertically_mirrored() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.vertically_mirrored)
  return _internal_vertically_mirrored();
}
inline void TrafficSign_MainSign_Classification::_internal_set_vertically_mirrored(bool value) {
  _has_bits_[0] |= 0x00000100u;
  vertically_mirrored_ = value;
}
inline void TrafficSign_MainSign_Classification::set_vertically_mirrored(bool value) {
  _internal_set_vertically_mirrored(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.vertically_mirrored)
}

// optional bool is_out_of_service = 7;
inline bool TrafficSign_MainSign_Classification::_internal_has_is_out_of_service() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_is_out_of_service() const {
  return _internal_has_is_out_of_service();
}
inline void TrafficSign_MainSign_Classification::clear_is_out_of_service() {
  is_out_of_service_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool TrafficSign_MainSign_Classification::_internal_is_out_of_service() const {
  return is_out_of_service_;
}
inline bool TrafficSign_MainSign_Classification::is_out_of_service() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.is_out_of_service)
  return _internal_is_out_of_service();
}
inline void TrafficSign_MainSign_Classification::_internal_set_is_out_of_service(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_out_of_service_ = value;
}
inline void TrafficSign_MainSign_Classification::set_is_out_of_service(bool value) {
  _internal_set_is_out_of_service(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.is_out_of_service)
}

// optional string country = 8;
inline bool TrafficSign_MainSign_Classification::_internal_has_country() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_country() const {
  return _internal_has_country();
}
inline void TrafficSign_MainSign_Classification::clear_country() {
  country_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign_MainSign_Classification::country() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.country)
  return _internal_country();
}
inline void TrafficSign_MainSign_Classification::set_country(const std::string& value) {
  _internal_set_country(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.country)
}
inline std::string* TrafficSign_MainSign_Classification::mutable_country() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.country)
  return _internal_mutable_country();
}
inline const std::string& TrafficSign_MainSign_Classification::_internal_country() const {
  return country_.GetNoArena();
}
inline void TrafficSign_MainSign_Classification::_internal_set_country(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  country_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_MainSign_Classification::set_country(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  country_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.MainSign.Classification.country)
}
inline void TrafficSign_MainSign_Classification::set_country(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  country_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.MainSign.Classification.country)
}
inline void TrafficSign_MainSign_Classification::set_country(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  country_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.MainSign.Classification.country)
}
inline std::string* TrafficSign_MainSign_Classification::_internal_mutable_country() {
  _has_bits_[0] |= 0x00000001u;
  return country_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_MainSign_Classification::release_country() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return country_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_MainSign_Classification::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  country_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.country)
}

// optional string country_revision = 9;
inline bool TrafficSign_MainSign_Classification::_internal_has_country_revision() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_country_revision() const {
  return _internal_has_country_revision();
}
inline void TrafficSign_MainSign_Classification::clear_country_revision() {
  country_revision_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrafficSign_MainSign_Classification::country_revision() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.country_revision)
  return _internal_country_revision();
}
inline void TrafficSign_MainSign_Classification::set_country_revision(const std::string& value) {
  _internal_set_country_revision(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.country_revision)
}
inline std::string* TrafficSign_MainSign_Classification::mutable_country_revision() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.country_revision)
  return _internal_mutable_country_revision();
}
inline const std::string& TrafficSign_MainSign_Classification::_internal_country_revision() const {
  return country_revision_.GetNoArena();
}
inline void TrafficSign_MainSign_Classification::_internal_set_country_revision(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  country_revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_MainSign_Classification::set_country_revision(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  country_revision_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.MainSign.Classification.country_revision)
}
inline void TrafficSign_MainSign_Classification::set_country_revision(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  country_revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.MainSign.Classification.country_revision)
}
inline void TrafficSign_MainSign_Classification::set_country_revision(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  country_revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.MainSign.Classification.country_revision)
}
inline std::string* TrafficSign_MainSign_Classification::_internal_mutable_country_revision() {
  _has_bits_[0] |= 0x00000002u;
  return country_revision_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_MainSign_Classification::release_country_revision() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.country_revision)
  if (!_internal_has_country_revision()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return country_revision_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_MainSign_Classification::set_allocated_country_revision(std::string* country_revision) {
  if (country_revision != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  country_revision_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country_revision);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.country_revision)
}

// optional string code = 10;
inline bool TrafficSign_MainSign_Classification::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_code() const {
  return _internal_has_code();
}
inline void TrafficSign_MainSign_Classification::clear_code() {
  code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TrafficSign_MainSign_Classification::code() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.code)
  return _internal_code();
}
inline void TrafficSign_MainSign_Classification::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.code)
}
inline std::string* TrafficSign_MainSign_Classification::mutable_code() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.code)
  return _internal_mutable_code();
}
inline const std::string& TrafficSign_MainSign_Classification::_internal_code() const {
  return code_.GetNoArena();
}
inline void TrafficSign_MainSign_Classification::_internal_set_code(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_MainSign_Classification::set_code(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.MainSign.Classification.code)
}
inline void TrafficSign_MainSign_Classification::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.MainSign.Classification.code)
}
inline void TrafficSign_MainSign_Classification::set_code(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.MainSign.Classification.code)
}
inline std::string* TrafficSign_MainSign_Classification::_internal_mutable_code() {
  _has_bits_[0] |= 0x00000004u;
  return code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_MainSign_Classification::release_code() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return code_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_MainSign_Classification::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.code)
}

// optional string sub_code = 11;
inline bool TrafficSign_MainSign_Classification::_internal_has_sub_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrafficSign_MainSign_Classification::has_sub_code() const {
  return _internal_has_sub_code();
}
inline void TrafficSign_MainSign_Classification::clear_sub_code() {
  sub_code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TrafficSign_MainSign_Classification::sub_code() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.sub_code)
  return _internal_sub_code();
}
inline void TrafficSign_MainSign_Classification::set_sub_code(const std::string& value) {
  _internal_set_sub_code(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.sub_code)
}
inline std::string* TrafficSign_MainSign_Classification::mutable_sub_code() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.sub_code)
  return _internal_mutable_sub_code();
}
inline const std::string& TrafficSign_MainSign_Classification::_internal_sub_code() const {
  return sub_code_.GetNoArena();
}
inline void TrafficSign_MainSign_Classification::_internal_set_sub_code(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  sub_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_MainSign_Classification::set_sub_code(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  sub_code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.MainSign.Classification.sub_code)
}
inline void TrafficSign_MainSign_Classification::set_sub_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  sub_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.MainSign.Classification.sub_code)
}
inline void TrafficSign_MainSign_Classification::set_sub_code(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  sub_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.MainSign.Classification.sub_code)
}
inline std::string* TrafficSign_MainSign_Classification::_internal_mutable_sub_code() {
  _has_bits_[0] |= 0x00000008u;
  return sub_code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_MainSign_Classification::release_sub_code() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.sub_code)
  if (!_internal_has_sub_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return sub_code_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_MainSign_Classification::set_allocated_sub_code(std::string* sub_code) {
  if (sub_code != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  sub_code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sub_code);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.sub_code)
}

// -------------------------------------------------------------------

// TrafficSign_MainSign

// optional .osi3.BaseStationary base = 1;
inline bool TrafficSign_MainSign::_internal_has_base() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || base_ != nullptr);
  return value;
}
inline bool TrafficSign_MainSign::has_base() const {
  return _internal_has_base();
}
inline const ::osi3::BaseStationary& TrafficSign_MainSign::_internal_base() const {
  const ::osi3::BaseStationary* p = base_;
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::BaseStationary*>(
      &::osi3::_BaseStationary_default_instance_);
}
inline const ::osi3::BaseStationary& TrafficSign_MainSign::base() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.base)
  return _internal_base();
}
inline ::osi3::BaseStationary* TrafficSign_MainSign::release_base() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.base)
  _has_bits_[0] &= ~0x00000002u;
  ::osi3::BaseStationary* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::osi3::BaseStationary* TrafficSign_MainSign::_internal_mutable_base() {
  _has_bits_[0] |= 0x00000002u;
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::BaseStationary>(GetArenaNoVirtual());
    base_ = p;
  }
  return base_;
}
inline ::osi3::BaseStationary* TrafficSign_MainSign::mutable_base() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.base)
  return _internal_mutable_base();
}
inline void TrafficSign_MainSign::set_allocated_base(::osi3::BaseStationary* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.base)
}

// optional .osi3.TrafficSign.MainSign.Classification classification = 2;
inline bool TrafficSign_MainSign::_internal_has_classification() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || classification_ != nullptr);
  return value;
}
inline bool TrafficSign_MainSign::has_classification() const {
  return _internal_has_classification();
}
inline void TrafficSign_MainSign::clear_classification() {
  if (classification_ != nullptr) classification_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::osi3::TrafficSign_MainSign_Classification& TrafficSign_MainSign::_internal_classification() const {
  const ::osi3::TrafficSign_MainSign_Classification* p = classification_;
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::TrafficSign_MainSign_Classification*>(
      &::osi3::_TrafficSign_MainSign_Classification_default_instance_);
}
inline const ::osi3::TrafficSign_MainSign_Classification& TrafficSign_MainSign::classification() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.classification)
  return _internal_classification();
}
inline ::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::release_classification() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.classification)
  _has_bits_[0] &= ~0x00000004u;
  ::osi3::TrafficSign_MainSign_Classification* temp = classification_;
  classification_ = nullptr;
  return temp;
}
inline ::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::_internal_mutable_classification() {
  _has_bits_[0] |= 0x00000004u;
  if (classification_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::TrafficSign_MainSign_Classification>(GetArenaNoVirtual());
    classification_ = p;
  }
  return classification_;
}
inline ::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::mutable_classification() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.classification)
  return _internal_mutable_classification();
}
inline void TrafficSign_MainSign::set_allocated_classification(::osi3::TrafficSign_MainSign_Classification* classification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete classification_;
  }
  if (classification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      classification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classification, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  classification_ = classification;
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.classification)
}

// optional string model_reference = 3;
inline bool TrafficSign_MainSign::_internal_has_model_reference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficSign_MainSign::has_model_reference() const {
  return _internal_has_model_reference();
}
inline void TrafficSign_MainSign::clear_model_reference() {
  model_reference_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign_MainSign::model_reference() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.model_reference)
  return _internal_model_reference();
}
inline void TrafficSign_MainSign::set_model_reference(const std::string& value) {
  _internal_set_model_reference(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.model_reference)
}
inline std::string* TrafficSign_MainSign::mutable_model_reference() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.model_reference)
  return _internal_mutable_model_reference();
}
inline const std::string& TrafficSign_MainSign::_internal_model_reference() const {
  return model_reference_.GetNoArena();
}
inline void TrafficSign_MainSign::_internal_set_model_reference(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_reference_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_MainSign::set_model_reference(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_reference_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.MainSign.model_reference)
}
inline void TrafficSign_MainSign::set_model_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_reference_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.MainSign.model_reference)
}
inline void TrafficSign_MainSign::set_model_reference(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_reference_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.MainSign.model_reference)
}
inline std::string* TrafficSign_MainSign::_internal_mutable_model_reference() {
  _has_bits_[0] |= 0x00000001u;
  return model_reference_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_MainSign::release_model_reference() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.model_reference)
  if (!_internal_has_model_reference()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_reference_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_MainSign::set_allocated_model_reference(std::string* model_reference) {
  if (model_reference != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_reference_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_reference);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.model_reference)
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySign_Classification_Arrow

// repeated .osi3.Identifier lane_id = 1;
inline int TrafficSign_SupplementarySign_Classification_Arrow::_internal_lane_id_size() const {
  return lane_id_.size();
}
inline int TrafficSign_SupplementarySign_Classification_Arrow::lane_id_size() const {
  return _internal_lane_id_size();
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification_Arrow::mutable_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return lane_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >*
TrafficSign_SupplementarySign_Classification_Arrow::mutable_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return &lane_id_;
}
inline const ::osi3::Identifier& TrafficSign_SupplementarySign_Classification_Arrow::_internal_lane_id(int index) const {
  return lane_id_.Get(index);
}
inline const ::osi3::Identifier& TrafficSign_SupplementarySign_Classification_Arrow::lane_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return _internal_lane_id(index);
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification_Arrow::_internal_add_lane_id() {
  return lane_id_.Add();
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification_Arrow::add_lane_id() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return _internal_add_lane_id();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >&
TrafficSign_SupplementarySign_Classification_Arrow::lane_id() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return lane_id_;
}

// repeated .osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction direction = 2;
inline int TrafficSign_SupplementarySign_Classification_Arrow::_internal_direction_size() const {
  return direction_.size();
}
inline int TrafficSign_SupplementarySign_Classification_Arrow::direction_size() const {
  return _internal_direction_size();
}
inline void TrafficSign_SupplementarySign_Classification_Arrow::clear_direction() {
  direction_.Clear();
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction TrafficSign_SupplementarySign_Classification_Arrow::_internal_direction(int index) const {
  return static_cast< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction >(direction_.Get(index));
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction TrafficSign_SupplementarySign_Classification_Arrow::direction(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
  return _internal_direction(index);
}
inline void TrafficSign_SupplementarySign_Classification_Arrow::set_direction(int index, ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction_IsValid(value));
  direction_.Set(index, value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
}
inline void TrafficSign_SupplementarySign_Classification_Arrow::_internal_add_direction(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction_IsValid(value));
  direction_.Add(value);
}
inline void TrafficSign_SupplementarySign_Classification_Arrow::add_direction(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value) {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
  _internal_add_direction(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TrafficSign_SupplementarySign_Classification_Arrow::direction() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
  return direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TrafficSign_SupplementarySign_Classification_Arrow::_internal_mutable_direction() {
  return &direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TrafficSign_SupplementarySign_Classification_Arrow::mutable_direction() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
  return _internal_mutable_direction();
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySign_Classification

// optional .osi3.TrafficSign.Variability variability = 1;
inline bool TrafficSign_SupplementarySign_Classification::_internal_has_variability() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TrafficSign_SupplementarySign_Classification::has_variability() const {
  return _internal_has_variability();
}
inline void TrafficSign_SupplementarySign_Classification::clear_variability() {
  variability_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::osi3::TrafficSign_Variability TrafficSign_SupplementarySign_Classification::_internal_variability() const {
  return static_cast< ::osi3::TrafficSign_Variability >(variability_);
}
inline ::osi3::TrafficSign_Variability TrafficSign_SupplementarySign_Classification::variability() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.variability)
  return _internal_variability();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_variability(::osi3::TrafficSign_Variability value) {
  assert(::osi3::TrafficSign_Variability_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  variability_ = value;
}
inline void TrafficSign_SupplementarySign_Classification::set_variability(::osi3::TrafficSign_Variability value) {
  _internal_set_variability(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.variability)
}

// optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
inline bool TrafficSign_SupplementarySign_Classification::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TrafficSign_SupplementarySign_Classification::has_type() const {
  return _internal_has_type();
}
inline void TrafficSign_SupplementarySign_Classification::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::_internal_type() const {
  return static_cast< ::osi3::TrafficSign_SupplementarySign_Classification_Type >(type_);
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::type() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.type)
  return _internal_type();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Type_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void TrafficSign_SupplementarySign_Classification::set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.type)
}

// repeated .osi3.TrafficSignValue value = 3;
inline int TrafficSign_SupplementarySign_Classification::_internal_value_size() const {
  return value_.size();
}
inline int TrafficSign_SupplementarySign_Classification::value_size() const {
  return _internal_value_size();
}
inline void TrafficSign_SupplementarySign_Classification::clear_value() {
  value_.Clear();
}
inline ::osi3::TrafficSignValue* TrafficSign_SupplementarySign_Classification::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSignValue >*
TrafficSign_SupplementarySign_Classification::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.value)
  return &value_;
}
inline const ::osi3::TrafficSignValue& TrafficSign_SupplementarySign_Classification::_internal_value(int index) const {
  return value_.Get(index);
}
inline const ::osi3::TrafficSignValue& TrafficSign_SupplementarySign_Classification::value(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.value)
  return _internal_value(index);
}
inline ::osi3::TrafficSignValue* TrafficSign_SupplementarySign_Classification::_internal_add_value() {
  return value_.Add();
}
inline ::osi3::TrafficSignValue* TrafficSign_SupplementarySign_Classification::add_value() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.value)
  return _internal_add_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSignValue >&
TrafficSign_SupplementarySign_Classification::value() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.value)
  return value_;
}

// repeated .osi3.Identifier assigned_lane_id = 4;
inline int TrafficSign_SupplementarySign_Classification::_internal_assigned_lane_id_size() const {
  return assigned_lane_id_.size();
}
inline int TrafficSign_SupplementarySign_Classification::assigned_lane_id_size() const {
  return _internal_assigned_lane_id_size();
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification::mutable_assigned_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return assigned_lane_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >*
TrafficSign_SupplementarySign_Classification::mutable_assigned_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return &assigned_lane_id_;
}
inline const ::osi3::Identifier& TrafficSign_SupplementarySign_Classification::_internal_assigned_lane_id(int index) const {
  return assigned_lane_id_.Get(index);
}
inline const ::osi3::Identifier& TrafficSign_SupplementarySign_Classification::assigned_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return _internal_assigned_lane_id(index);
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification::_internal_add_assigned_lane_id() {
  return assigned_lane_id_.Add();
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification::add_assigned_lane_id() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return _internal_add_assigned_lane_id();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::Identifier >&
TrafficSign_SupplementarySign_Classification::assigned_lane_id() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return assigned_lane_id_;
}

// repeated .osi3.TrafficSign.SupplementarySign.Classification.Actor actor = 5;
inline int TrafficSign_SupplementarySign_Classification::_internal_actor_size() const {
  return actor_.size();
}
inline int TrafficSign_SupplementarySign_Classification::actor_size() const {
  return _internal_actor_size();
}
inline void TrafficSign_SupplementarySign_Classification::clear_actor() {
  actor_.Clear();
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Actor TrafficSign_SupplementarySign_Classification::_internal_actor(int index) const {
  return static_cast< ::osi3::TrafficSign_SupplementarySign_Classification_Actor >(actor_.Get(index));
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Actor TrafficSign_SupplementarySign_Classification::actor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.actor)
  return _internal_actor(index);
}
inline void TrafficSign_SupplementarySign_Classification::set_actor(int index, ::osi3::TrafficSign_SupplementarySign_Classification_Actor value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Actor_IsValid(value));
  actor_.Set(index, value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.actor)
}
inline void TrafficSign_SupplementarySign_Classification::_internal_add_actor(::osi3::TrafficSign_SupplementarySign_Classification_Actor value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Actor_IsValid(value));
  actor_.Add(value);
}
inline void TrafficSign_SupplementarySign_Classification::add_actor(::osi3::TrafficSign_SupplementarySign_Classification_Actor value) {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.actor)
  _internal_add_actor(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TrafficSign_SupplementarySign_Classification::actor() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.actor)
  return actor_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TrafficSign_SupplementarySign_Classification::_internal_mutable_actor() {
  return &actor_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TrafficSign_SupplementarySign_Classification::mutable_actor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.actor)
  return _internal_mutable_actor();
}

// repeated .osi3.TrafficSign.SupplementarySign.Classification.Arrow arrow = 6;
inline int TrafficSign_SupplementarySign_Classification::_internal_arrow_size() const {
  return arrow_.size();
}
inline int TrafficSign_SupplementarySign_Classification::arrow_size() const {
  return _internal_arrow_size();
}
inline void TrafficSign_SupplementarySign_Classification::clear_arrow() {
  arrow_.Clear();
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* TrafficSign_SupplementarySign_Classification::mutable_arrow(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return arrow_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow >*
TrafficSign_SupplementarySign_Classification::mutable_arrow() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return &arrow_;
}
inline const ::osi3::TrafficSign_SupplementarySign_Classification_Arrow& TrafficSign_SupplementarySign_Classification::_internal_arrow(int index) const {
  return arrow_.Get(index);
}
inline const ::osi3::TrafficSign_SupplementarySign_Classification_Arrow& TrafficSign_SupplementarySign_Classification::arrow(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return _internal_arrow(index);
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* TrafficSign_SupplementarySign_Classification::_internal_add_arrow() {
  return arrow_.Add();
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* TrafficSign_SupplementarySign_Classification::add_arrow() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return _internal_add_arrow();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow >&
TrafficSign_SupplementarySign_Classification::arrow() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return arrow_;
}

// optional bool is_out_of_service = 7;
inline bool TrafficSign_SupplementarySign_Classification::_internal_has_is_out_of_service() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TrafficSign_SupplementarySign_Classification::has_is_out_of_service() const {
  return _internal_has_is_out_of_service();
}
inline void TrafficSign_SupplementarySign_Classification::clear_is_out_of_service() {
  is_out_of_service_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool TrafficSign_SupplementarySign_Classification::_internal_is_out_of_service() const {
  return is_out_of_service_;
}
inline bool TrafficSign_SupplementarySign_Classification::is_out_of_service() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.is_out_of_service)
  return _internal_is_out_of_service();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_is_out_of_service(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_out_of_service_ = value;
}
inline void TrafficSign_SupplementarySign_Classification::set_is_out_of_service(bool value) {
  _internal_set_is_out_of_service(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.is_out_of_service)
}

// optional string country = 8;
inline bool TrafficSign_SupplementarySign_Classification::_internal_has_country() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficSign_SupplementarySign_Classification::has_country() const {
  return _internal_has_country();
}
inline void TrafficSign_SupplementarySign_Classification::clear_country() {
  country_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::country() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.country)
  return _internal_country();
}
inline void TrafficSign_SupplementarySign_Classification::set_country(const std::string& value) {
  _internal_set_country(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.country)
}
inline std::string* TrafficSign_SupplementarySign_Classification::mutable_country() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.country)
  return _internal_mutable_country();
}
inline const std::string& TrafficSign_SupplementarySign_Classification::_internal_country() const {
  return country_.GetNoArena();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_country(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  country_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_SupplementarySign_Classification::set_country(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  country_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.SupplementarySign.Classification.country)
}
inline void TrafficSign_SupplementarySign_Classification::set_country(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  country_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.SupplementarySign.Classification.country)
}
inline void TrafficSign_SupplementarySign_Classification::set_country(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  country_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.SupplementarySign.Classification.country)
}
inline std::string* TrafficSign_SupplementarySign_Classification::_internal_mutable_country() {
  _has_bits_[0] |= 0x00000001u;
  return country_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_SupplementarySign_Classification::release_country() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.Classification.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return country_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_SupplementarySign_Classification::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  country_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.Classification.country)
}

// optional string country_revision = 9;
inline bool TrafficSign_SupplementarySign_Classification::_internal_has_country_revision() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficSign_SupplementarySign_Classification::has_country_revision() const {
  return _internal_has_country_revision();
}
inline void TrafficSign_SupplementarySign_Classification::clear_country_revision() {
  country_revision_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::country_revision() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
  return _internal_country_revision();
}
inline void TrafficSign_SupplementarySign_Classification::set_country_revision(const std::string& value) {
  _internal_set_country_revision(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
}
inline std::string* TrafficSign_SupplementarySign_Classification::mutable_country_revision() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
  return _internal_mutable_country_revision();
}
inline const std::string& TrafficSign_SupplementarySign_Classification::_internal_country_revision() const {
  return country_revision_.GetNoArena();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_country_revision(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  country_revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_SupplementarySign_Classification::set_country_revision(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  country_revision_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
}
inline void TrafficSign_SupplementarySign_Classification::set_country_revision(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  country_revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
}
inline void TrafficSign_SupplementarySign_Classification::set_country_revision(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  country_revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
}
inline std::string* TrafficSign_SupplementarySign_Classification::_internal_mutable_country_revision() {
  _has_bits_[0] |= 0x00000002u;
  return country_revision_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_SupplementarySign_Classification::release_country_revision() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
  if (!_internal_has_country_revision()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return country_revision_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_SupplementarySign_Classification::set_allocated_country_revision(std::string* country_revision) {
  if (country_revision != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  country_revision_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country_revision);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
}

// optional string code = 10;
inline bool TrafficSign_SupplementarySign_Classification::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficSign_SupplementarySign_Classification::has_code() const {
  return _internal_has_code();
}
inline void TrafficSign_SupplementarySign_Classification::clear_code() {
  code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::code() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.code)
  return _internal_code();
}
inline void TrafficSign_SupplementarySign_Classification::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.code)
}
inline std::string* TrafficSign_SupplementarySign_Classification::mutable_code() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.code)
  return _internal_mutable_code();
}
inline const std::string& TrafficSign_SupplementarySign_Classification::_internal_code() const {
  return code_.GetNoArena();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_code(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_SupplementarySign_Classification::set_code(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.SupplementarySign.Classification.code)
}
inline void TrafficSign_SupplementarySign_Classification::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.SupplementarySign.Classification.code)
}
inline void TrafficSign_SupplementarySign_Classification::set_code(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.SupplementarySign.Classification.code)
}
inline std::string* TrafficSign_SupplementarySign_Classification::_internal_mutable_code() {
  _has_bits_[0] |= 0x00000004u;
  return code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_SupplementarySign_Classification::release_code() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.Classification.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return code_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_SupplementarySign_Classification::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.Classification.code)
}

// optional string sub_code = 11;
inline bool TrafficSign_SupplementarySign_Classification::_internal_has_sub_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrafficSign_SupplementarySign_Classification::has_sub_code() const {
  return _internal_has_sub_code();
}
inline void TrafficSign_SupplementarySign_Classification::clear_sub_code() {
  sub_code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::sub_code() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
  return _internal_sub_code();
}
inline void TrafficSign_SupplementarySign_Classification::set_sub_code(const std::string& value) {
  _internal_set_sub_code(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
}
inline std::string* TrafficSign_SupplementarySign_Classification::mutable_sub_code() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
  return _internal_mutable_sub_code();
}
inline const std::string& TrafficSign_SupplementarySign_Classification::_internal_sub_code() const {
  return sub_code_.GetNoArena();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_sub_code(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  sub_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_SupplementarySign_Classification::set_sub_code(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  sub_code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
}
inline void TrafficSign_SupplementarySign_Classification::set_sub_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  sub_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
}
inline void TrafficSign_SupplementarySign_Classification::set_sub_code(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  sub_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
}
inline std::string* TrafficSign_SupplementarySign_Classification::_internal_mutable_sub_code() {
  _has_bits_[0] |= 0x00000008u;
  return sub_code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_SupplementarySign_Classification::release_sub_code() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
  if (!_internal_has_sub_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return sub_code_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_SupplementarySign_Classification::set_allocated_sub_code(std::string* sub_code) {
  if (sub_code != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  sub_code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sub_code);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySign

// optional .osi3.BaseStationary base = 1;
inline bool TrafficSign_SupplementarySign::_internal_has_base() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || base_ != nullptr);
  return value;
}
inline bool TrafficSign_SupplementarySign::has_base() const {
  return _internal_has_base();
}
inline const ::osi3::BaseStationary& TrafficSign_SupplementarySign::_internal_base() const {
  const ::osi3::BaseStationary* p = base_;
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::BaseStationary*>(
      &::osi3::_BaseStationary_default_instance_);
}
inline const ::osi3::BaseStationary& TrafficSign_SupplementarySign::base() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.base)
  return _internal_base();
}
inline ::osi3::BaseStationary* TrafficSign_SupplementarySign::release_base() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.base)
  _has_bits_[0] &= ~0x00000002u;
  ::osi3::BaseStationary* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::osi3::BaseStationary* TrafficSign_SupplementarySign::_internal_mutable_base() {
  _has_bits_[0] |= 0x00000002u;
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::BaseStationary>(GetArenaNoVirtual());
    base_ = p;
  }
  return base_;
}
inline ::osi3::BaseStationary* TrafficSign_SupplementarySign::mutable_base() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.base)
  return _internal_mutable_base();
}
inline void TrafficSign_SupplementarySign::set_allocated_base(::osi3::BaseStationary* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.base)
}

// optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
inline bool TrafficSign_SupplementarySign::_internal_has_classification() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || classification_ != nullptr);
  return value;
}
inline bool TrafficSign_SupplementarySign::has_classification() const {
  return _internal_has_classification();
}
inline void TrafficSign_SupplementarySign::clear_classification() {
  if (classification_ != nullptr) classification_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::osi3::TrafficSign_SupplementarySign_Classification& TrafficSign_SupplementarySign::_internal_classification() const {
  const ::osi3::TrafficSign_SupplementarySign_Classification* p = classification_;
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::TrafficSign_SupplementarySign_Classification*>(
      &::osi3::_TrafficSign_SupplementarySign_Classification_default_instance_);
}
inline const ::osi3::TrafficSign_SupplementarySign_Classification& TrafficSign_SupplementarySign::classification() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.classification)
  return _internal_classification();
}
inline ::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::release_classification() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.classification)
  _has_bits_[0] &= ~0x00000004u;
  ::osi3::TrafficSign_SupplementarySign_Classification* temp = classification_;
  classification_ = nullptr;
  return temp;
}
inline ::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::_internal_mutable_classification() {
  _has_bits_[0] |= 0x00000004u;
  if (classification_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::TrafficSign_SupplementarySign_Classification>(GetArenaNoVirtual());
    classification_ = p;
  }
  return classification_;
}
inline ::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::mutable_classification() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.classification)
  return _internal_mutable_classification();
}
inline void TrafficSign_SupplementarySign::set_allocated_classification(::osi3::TrafficSign_SupplementarySign_Classification* classification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete classification_;
  }
  if (classification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      classification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classification, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  classification_ = classification;
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.classification)
}

// optional string model_reference = 3;
inline bool TrafficSign_SupplementarySign::_internal_has_model_reference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficSign_SupplementarySign::has_model_reference() const {
  return _internal_has_model_reference();
}
inline void TrafficSign_SupplementarySign::clear_model_reference() {
  model_reference_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign_SupplementarySign::model_reference() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.model_reference)
  return _internal_model_reference();
}
inline void TrafficSign_SupplementarySign::set_model_reference(const std::string& value) {
  _internal_set_model_reference(value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.model_reference)
}
inline std::string* TrafficSign_SupplementarySign::mutable_model_reference() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.model_reference)
  return _internal_mutable_model_reference();
}
inline const std::string& TrafficSign_SupplementarySign::_internal_model_reference() const {
  return model_reference_.GetNoArena();
}
inline void TrafficSign_SupplementarySign::_internal_set_model_reference(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_reference_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TrafficSign_SupplementarySign::set_model_reference(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_reference_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:osi3.TrafficSign.SupplementarySign.model_reference)
}
inline void TrafficSign_SupplementarySign::set_model_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_reference_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:osi3.TrafficSign.SupplementarySign.model_reference)
}
inline void TrafficSign_SupplementarySign::set_model_reference(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_reference_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:osi3.TrafficSign.SupplementarySign.model_reference)
}
inline std::string* TrafficSign_SupplementarySign::_internal_mutable_model_reference() {
  _has_bits_[0] |= 0x00000001u;
  return model_reference_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TrafficSign_SupplementarySign::release_model_reference() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.model_reference)
  if (!_internal_has_model_reference()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_reference_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign_SupplementarySign::set_allocated_model_reference(std::string* model_reference) {
  if (model_reference != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_reference_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_reference);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.model_reference)
}

// -------------------------------------------------------------------

// TrafficSign

// optional .osi3.Identifier id = 1;
inline bool TrafficSign::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool TrafficSign::has_id() const {
  return _internal_has_id();
}
inline const ::osi3::Identifier& TrafficSign::_internal_id() const {
  const ::osi3::Identifier* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& TrafficSign::id() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.id)
  return _internal_id();
}
inline ::osi3::Identifier* TrafficSign::release_id() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.id)
  _has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* TrafficSign::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    id_ = p;
  }
  return id_;
}
inline ::osi3::Identifier* TrafficSign::mutable_id() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.id)
  return _internal_mutable_id();
}
inline void TrafficSign::set_allocated_id(::osi3::Identifier* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.id)
}

// optional .osi3.TrafficSign.MainSign main_sign = 2;
inline bool TrafficSign::_internal_has_main_sign() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || main_sign_ != nullptr);
  return value;
}
inline bool TrafficSign::has_main_sign() const {
  return _internal_has_main_sign();
}
inline void TrafficSign::clear_main_sign() {
  if (main_sign_ != nullptr) main_sign_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::TrafficSign_MainSign& TrafficSign::_internal_main_sign() const {
  const ::osi3::TrafficSign_MainSign* p = main_sign_;
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::TrafficSign_MainSign*>(
      &::osi3::_TrafficSign_MainSign_default_instance_);
}
inline const ::osi3::TrafficSign_MainSign& TrafficSign::main_sign() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.main_sign)
  return _internal_main_sign();
}
inline ::osi3::TrafficSign_MainSign* TrafficSign::release_main_sign() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.main_sign)
  _has_bits_[0] &= ~0x00000002u;
  ::osi3::TrafficSign_MainSign* temp = main_sign_;
  main_sign_ = nullptr;
  return temp;
}
inline ::osi3::TrafficSign_MainSign* TrafficSign::_internal_mutable_main_sign() {
  _has_bits_[0] |= 0x00000002u;
  if (main_sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::TrafficSign_MainSign>(GetArenaNoVirtual());
    main_sign_ = p;
  }
  return main_sign_;
}
inline ::osi3::TrafficSign_MainSign* TrafficSign::mutable_main_sign() {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.main_sign)
  return _internal_mutable_main_sign();
}
inline void TrafficSign::set_allocated_main_sign(::osi3::TrafficSign_MainSign* main_sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete main_sign_;
  }
  if (main_sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      main_sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, main_sign, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  main_sign_ = main_sign;
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.main_sign)
}

// repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
inline int TrafficSign::_internal_supplementary_sign_size() const {
  return supplementary_sign_.size();
}
inline int TrafficSign::supplementary_sign_size() const {
  return _internal_supplementary_sign_size();
}
inline void TrafficSign::clear_supplementary_sign() {
  supplementary_sign_.Clear();
}
inline ::osi3::TrafficSign_SupplementarySign* TrafficSign::mutable_supplementary_sign(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.supplementary_sign)
  return supplementary_sign_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign >*
TrafficSign::mutable_supplementary_sign() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.supplementary_sign)
  return &supplementary_sign_;
}
inline const ::osi3::TrafficSign_SupplementarySign& TrafficSign::_internal_supplementary_sign(int index) const {
  return supplementary_sign_.Get(index);
}
inline const ::osi3::TrafficSign_SupplementarySign& TrafficSign::supplementary_sign(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.supplementary_sign)
  return _internal_supplementary_sign(index);
}
inline ::osi3::TrafficSign_SupplementarySign* TrafficSign::_internal_add_supplementary_sign() {
  return supplementary_sign_.Add();
}
inline ::osi3::TrafficSign_SupplementarySign* TrafficSign::add_supplementary_sign() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.supplementary_sign)
  return _internal_add_supplementary_sign();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign >&
TrafficSign::supplementary_sign() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.supplementary_sign)
  return supplementary_sign_;
}

// repeated .osi3.ExternalReference source_reference = 4;
inline int TrafficSign::_internal_source_reference_size() const {
  return source_reference_.size();
}
inline int TrafficSign::source_reference_size() const {
  return _internal_source_reference_size();
}
inline ::osi3::ExternalReference* TrafficSign::mutable_source_reference(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.source_reference)
  return source_reference_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::ExternalReference >*
TrafficSign::mutable_source_reference() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.source_reference)
  return &source_reference_;
}
inline const ::osi3::ExternalReference& TrafficSign::_internal_source_reference(int index) const {
  return source_reference_.Get(index);
}
inline const ::osi3::ExternalReference& TrafficSign::source_reference(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.source_reference)
  return _internal_source_reference(index);
}
inline ::osi3::ExternalReference* TrafficSign::_internal_add_source_reference() {
  return source_reference_.Add();
}
inline ::osi3::ExternalReference* TrafficSign::add_source_reference() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.source_reference)
  return _internal_add_source_reference();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::ExternalReference >&
TrafficSign::source_reference() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.source_reference)
  return source_reference_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace osi3

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::osi3::TrafficSignValue_Unit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::TrafficSignValue_Unit>() {
  return ::osi3::TrafficSignValue_Unit_descriptor();
}
template <> struct is_proto_enum< ::osi3::TrafficSign_MainSign_Classification_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::TrafficSign_MainSign_Classification_Type>() {
  return ::osi3::TrafficSign_MainSign_Classification_Type_descriptor();
}
template <> struct is_proto_enum< ::osi3::TrafficSign_MainSign_Classification_DirectionScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::TrafficSign_MainSign_Classification_DirectionScope>() {
  return ::osi3::TrafficSign_MainSign_Classification_DirectionScope_descriptor();
}
template <> struct is_proto_enum< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction>() {
  return ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor();
}
template <> struct is_proto_enum< ::osi3::TrafficSign_SupplementarySign_Classification_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::TrafficSign_SupplementarySign_Classification_Type>() {
  return ::osi3::TrafficSign_SupplementarySign_Classification_Type_descriptor();
}
template <> struct is_proto_enum< ::osi3::TrafficSign_SupplementarySign_Classification_Actor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::TrafficSign_SupplementarySign_Classification_Actor>() {
  return ::osi3::TrafficSign_SupplementarySign_Classification_Actor_descriptor();
}
template <> struct is_proto_enum< ::osi3::TrafficSign_Variability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::TrafficSign_Variability>() {
  return ::osi3::TrafficSign_Variability_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_osi_5ftrafficsign_2eproto
