/* -*- C++ -*- */
/* Generated by /home/shan/git/bsp/adcm_bsp_sa8195/sources/apps/apps_proc/poky/build/tmp-glibc/work/aarch64-oe-linux/opendds/1.0+gitAUTOINC+0810ffc3f5-r7/recipe-sysroot-native/usr/bin/DDS_HOST_ROOT/bin/opendds_idl version 3.13 (ACE version 6.5.12) running on input file DdsDcpsCore.idl */
#ifndef OPENDDS_IDL_GENERATED_DDSDCPSCORETYPESUPPORTIMPL_H_49UCUN
#define OPENDDS_IDL_GENERATED_DDSDCPSCORETYPESUPPORTIMPL_H_49UCUN
#include "DdsDcpsCoreC.h"
#include "dds/DCPS/Definitions.h"
#include "dds/DdsDcpsC.h"
#include "DdsDcpsCoreTypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "tao/LongSeqC.h"
#include "tao/StringSeqC.h"
#include "dds/DCPS/dcps_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::StringSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::StringSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::StringSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::StringSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::BuiltinTopicKeyValue_forany& arr, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::BuiltinTopicKeyValue_forany& arr);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::BuiltinTopicKeyValue_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::BuiltinTopicKeyValue_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin TYPEDEF: InstanceHandleSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::InstanceHandleSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::InstanceHandleSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::InstanceHandleSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::InstanceHandleSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::QosPolicyCount& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::QosPolicyCount& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::QosPolicyCount& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::QosPolicyCount>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::QosPolicyCount*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::QosPolicyCountSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::QosPolicyCountSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::QosPolicyCountSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::QosPolicyCountSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::OctetSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OctetSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OctetSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::OctetSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::Duration_t& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::Duration_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::Duration_t& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::Duration_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::Duration_t*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::Property_t& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::Property_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::Property_t& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::Property_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::Property_t*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PropertySeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PropertySeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PropertySeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::PropertySeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::BinaryProperty_t& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::BinaryProperty_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::BinaryProperty_t& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::BinaryProperty_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::BinaryProperty_t*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::BinaryPropertySeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::BinaryPropertySeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::BinaryPropertySeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::BinaryPropertySeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PropertyQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PropertyQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PropertyQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PropertyQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::PropertyQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::UserDataQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::UserDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::UserDataQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::UserDataQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::UserDataQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::GroupDataQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::GroupDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::GroupDataQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::GroupDataQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::GroupDataQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TopicDataQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TopicDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TopicDataQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TopicDataQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::TopicDataQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PartitionQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PartitionQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PartitionQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PartitionQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::PartitionQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::HistoryQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::HistoryQosPolicyKind& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_HistoryQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_HistoryQosPolicyKind_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DurabilityQosPolicyKind& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_DurabilityQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_DurabilityQosPolicyKind_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DurabilityQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DurabilityQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DurabilityQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::DurabilityQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DurabilityServiceQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DurabilityServiceQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DurabilityServiceQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DurabilityServiceQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::DurabilityServiceQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DeadlineQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DeadlineQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DeadlineQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DeadlineQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::DeadlineQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::LatencyBudgetQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LatencyBudgetQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LatencyBudgetQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::LatencyBudgetQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::LatencyBudgetQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LivelinessQosPolicyKind& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_LivelinessQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_LivelinessQosPolicyKind_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::LivelinessQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LivelinessQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::LivelinessQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::LivelinessQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicyKind& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_ReliabilityQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_ReliabilityQosPolicyKind_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ReliabilityQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::ReliabilityQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::ReliabilityQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicyKind& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_DestinationOrderQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_DestinationOrderQosPolicyKind_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DestinationOrderQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DestinationOrderQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::DestinationOrderQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::HistoryQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::HistoryQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::HistoryQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::HistoryQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::HistoryQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ResourceLimitsQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ResourceLimitsQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ResourceLimitsQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::ResourceLimitsQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::ResourceLimitsQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TransportPriorityQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TransportPriorityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TransportPriorityQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TransportPriorityQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::TransportPriorityQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::LifespanQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::LifespanQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::LifespanQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::LifespanQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::LifespanQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OwnershipQosPolicyKind& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_OwnershipQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_OwnershipQosPolicyKind_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::OwnershipQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OwnershipQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::OwnershipQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::OwnershipQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::OwnershipStrengthQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::OwnershipStrengthQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::OwnershipStrengthQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::OwnershipStrengthQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::OwnershipStrengthQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PresentationQosPolicyAccessScopeKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PresentationQosPolicyAccessScopeKind& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_PresentationQosPolicyAccessScopeKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_PresentationQosPolicyAccessScopeKind_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PresentationQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PresentationQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PresentationQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PresentationQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::PresentationQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TimeBasedFilterQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TimeBasedFilterQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TimeBasedFilterQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TimeBasedFilterQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::TimeBasedFilterQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: TopicQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TopicQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TopicQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TopicQos& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TopicQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::TopicQos*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::WriterDataLifecycleQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::WriterDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::WriterDataLifecycleQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::WriterDataLifecycleQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::WriterDataLifecycleQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DataWriterQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DataWriterQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DataWriterQos& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DataWriterQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::DataWriterQos*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::EntityFactoryQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::EntityFactoryQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::EntityFactoryQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::EntityFactoryQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::EntityFactoryQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PublisherQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PublisherQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PublisherQos& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PublisherQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::PublisherQos*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ReaderDataLifecycleQosPolicy& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ReaderDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ReaderDataLifecycleQosPolicy& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::ReaderDataLifecycleQosPolicy*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DataReaderQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DataReaderQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DataReaderQos& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DataReaderQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::DataReaderQos*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SubscriberQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SubscriberQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SubscriberQos& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SubscriberQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::SubscriberQos*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DomainParticipantFactoryQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DomainParticipantFactoryQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DomainParticipantFactoryQos& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DomainParticipantFactoryQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::DomainParticipantFactoryQos*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::DomainParticipantQos& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::DomainParticipantQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::DomainParticipantQos& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::DomainParticipantQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::DomainParticipantQos*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: BuiltinTopicKey_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::BuiltinTopicKey_t& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::BuiltinTopicKey_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::BuiltinTopicKey_t& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::BuiltinTopicKey_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::BuiltinTopicKey_t*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::ParticipantBuiltinTopicData& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::ParticipantBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::ParticipantBuiltinTopicData& stru);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(const DDS::ParticipantBuiltinTopicData& stru, bool align);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, bool align);

OpenDDS_Dcps_Export
void gen_find_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, KeyOnly<const DDS::ParticipantBuiltinTopicData> stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, KeyOnly<DDS::ParticipantBuiltinTopicData> stru);

template <>
struct MarshalTraits<DDS::ParticipantBuiltinTopicData> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Dcps_Export ParticipantBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const DDS::ParticipantBuiltinTopicData& v1, const DDS::ParticipantBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    return false;
  }
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class ParticipantBuiltinTopicDataTypeSupportImpl;
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<DDS::ParticipantBuiltinTopicData> {
  typedef DDS::ParticipantBuiltinTopicData MessageType;
  typedef DDS::ParticipantBuiltinTopicDataSeq MessageSequenceType;
  typedef DDS::ParticipantBuiltinTopicDataTypeSupport TypeSupportType;
  typedef DDS::ParticipantBuiltinTopicDataTypeSupportImpl TypeSupportTypeImpl;
  typedef DDS::ParticipantBuiltinTopicDataDataWriter DataWriterType;
  typedef DDS::ParticipantBuiltinTopicDataDataReader DataReaderType;
  typedef DDS::ParticipantBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "DDS::ParticipantBuiltinTopicData"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class OpenDDS_Dcps_Export ParticipantBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<ParticipantBuiltinTopicData> TraitsType;
  typedef ParticipantBuiltinTopicDataTypeSupport TypeSupportType;
  typedef ParticipantBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef ParticipantBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  ParticipantBuiltinTopicDataTypeSupportImpl() {}
  virtual ~ParticipantBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static ParticipantBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::ParticipantBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::ParticipantBuiltinTopicData*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::PublicationBuiltinTopicData& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::PublicationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::PublicationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(const DDS::PublicationBuiltinTopicData& stru, bool align);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, bool align);

OpenDDS_Dcps_Export
void gen_find_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, KeyOnly<const DDS::PublicationBuiltinTopicData> stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, KeyOnly<DDS::PublicationBuiltinTopicData> stru);

template <>
struct MarshalTraits<DDS::PublicationBuiltinTopicData> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Dcps_Export PublicationBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const DDS::PublicationBuiltinTopicData& v1, const DDS::PublicationBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    return false;
  }
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class PublicationBuiltinTopicDataTypeSupportImpl;
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<DDS::PublicationBuiltinTopicData> {
  typedef DDS::PublicationBuiltinTopicData MessageType;
  typedef DDS::PublicationBuiltinTopicDataSeq MessageSequenceType;
  typedef DDS::PublicationBuiltinTopicDataTypeSupport TypeSupportType;
  typedef DDS::PublicationBuiltinTopicDataTypeSupportImpl TypeSupportTypeImpl;
  typedef DDS::PublicationBuiltinTopicDataDataWriter DataWriterType;
  typedef DDS::PublicationBuiltinTopicDataDataReader DataReaderType;
  typedef DDS::PublicationBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "DDS::PublicationBuiltinTopicData"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class OpenDDS_Dcps_Export PublicationBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublicationBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<PublicationBuiltinTopicData> TraitsType;
  typedef PublicationBuiltinTopicDataTypeSupport TypeSupportType;
  typedef PublicationBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef PublicationBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  PublicationBuiltinTopicDataTypeSupportImpl() {}
  virtual ~PublicationBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static PublicationBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::PublicationBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::PublicationBuiltinTopicData*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SubscriptionBuiltinTopicData& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SubscriptionBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SubscriptionBuiltinTopicData& stru);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(const DDS::SubscriptionBuiltinTopicData& stru, bool align);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, bool align);

OpenDDS_Dcps_Export
void gen_find_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, KeyOnly<DDS::SubscriptionBuiltinTopicData> stru);

template <>
struct MarshalTraits<DDS::SubscriptionBuiltinTopicData> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Dcps_Export SubscriptionBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const DDS::SubscriptionBuiltinTopicData& v1, const DDS::SubscriptionBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    return false;
  }
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class SubscriptionBuiltinTopicDataTypeSupportImpl;
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<DDS::SubscriptionBuiltinTopicData> {
  typedef DDS::SubscriptionBuiltinTopicData MessageType;
  typedef DDS::SubscriptionBuiltinTopicDataSeq MessageSequenceType;
  typedef DDS::SubscriptionBuiltinTopicDataTypeSupport TypeSupportType;
  typedef DDS::SubscriptionBuiltinTopicDataTypeSupportImpl TypeSupportTypeImpl;
  typedef DDS::SubscriptionBuiltinTopicDataDataWriter DataWriterType;
  typedef DDS::SubscriptionBuiltinTopicDataDataReader DataReaderType;
  typedef DDS::SubscriptionBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "DDS::SubscriptionBuiltinTopicData"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class OpenDDS_Dcps_Export SubscriptionBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriptionBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SubscriptionBuiltinTopicData> TraitsType;
  typedef SubscriptionBuiltinTopicDataTypeSupport TypeSupportType;
  typedef SubscriptionBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef SubscriptionBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  SubscriptionBuiltinTopicDataTypeSupportImpl() {}
  virtual ~SubscriptionBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SubscriptionBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SubscriptionBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::SubscriptionBuiltinTopicData*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::TopicBuiltinTopicData& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::TopicBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::TopicBuiltinTopicData& stru);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(const DDS::TopicBuiltinTopicData& stru, bool align);

OpenDDS_Dcps_Export
size_t gen_max_marshaled_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, bool align);

OpenDDS_Dcps_Export
void gen_find_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, KeyOnly<const DDS::TopicBuiltinTopicData> stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, KeyOnly<DDS::TopicBuiltinTopicData> stru);

template <>
struct MarshalTraits<DDS::TopicBuiltinTopicData> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_Dcps_Export TopicBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const DDS::TopicBuiltinTopicData& v1, const DDS::TopicBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    return false;
  }
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class TopicBuiltinTopicDataTypeSupportImpl;
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<DDS::TopicBuiltinTopicData> {
  typedef DDS::TopicBuiltinTopicData MessageType;
  typedef DDS::TopicBuiltinTopicDataSeq MessageSequenceType;
  typedef DDS::TopicBuiltinTopicDataTypeSupport TypeSupportType;
  typedef DDS::TopicBuiltinTopicDataTypeSupportImpl TypeSupportTypeImpl;
  typedef DDS::TopicBuiltinTopicDataDataWriter DataWriterType;
  typedef DDS::TopicBuiltinTopicDataDataReader DataReaderType;
  typedef DDS::TopicBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "DDS::TopicBuiltinTopicData"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class OpenDDS_Dcps_Export TopicBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<TopicBuiltinTopicData> TraitsType;
  typedef TopicBuiltinTopicDataTypeSupport TypeSupportType;
  typedef TopicBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef TopicBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  TopicBuiltinTopicDataTypeSupportImpl() {}
  virtual ~TopicBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static TopicBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::TopicBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::TopicBuiltinTopicData*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::Time_t& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::Time_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::Time_t& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::Time_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::Time_t*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SampleInfo& stru, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SampleInfo& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SampleInfo& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct<DDS::SampleInfo>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::SampleInfo*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void gen_find_size(const DDS::SampleInfoSeq& seq, size_t& size, size_t& padding);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const DDS::SampleInfoSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, DDS::SampleInfoSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser, DDS::SampleInfoSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */
#endif /* OPENDDS_IDL_GENERATED_DDSDCPSCORETYPESUPPORTIMPL_H_49UCUN */
