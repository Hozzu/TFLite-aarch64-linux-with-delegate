/* -*- C++ -*- */
/* Generated by /home/shan/git/bsp/adcm_bsp_sa8195/sources/apps/apps_proc/poky/build/tmp-glibc/work/aarch64-oe-linux/opendds/1.0+gitAUTOINC+0810ffc3f5-r7/recipe-sysroot-native/usr/bin/DDS_HOST_ROOT/bin/opendds_idl version 3.13 (ACE version 6.5.12) running on input file monitor.idl */
#ifndef OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_8WWFDX
#define OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_8WWFDX
#include "monitorC.h"
#include "dds/DCPS/Definitions.h"
#include "dds/DdsDcpsC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DdsDcpsGuidC.h"
#include "dds/DdsDcpsInfrastructureC.h"
#include "monitorTypeSupportC.h"
#include "tao/ULongSeqC.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */


/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin INTERFACE-FWD: Condition */


/* End INTERFACE-FWD: Condition */


/* Begin TYPEDEF: ConditionSeq */


/* End TYPEDEF: ConditionSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: ReturnCode_t */


/* End TYPEDEF: ReturnCode_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */


/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */


/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */


/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */


/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */


/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */


/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */


/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */


/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: OfferedIncompatibleQosStatus */


/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */


/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */


/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */


/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ULongSeq */


/* End TYPEDEF: ULongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: MONITOR_DOMAIN_ID */


/* End CONST: MONITOR_DOMAIN_ID */


/* Begin CONST: MONITOR_TRANSPORT_ID */


/* End CONST: MONITOR_TRANSPORT_ID */


/* Begin CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: TOPIC_MONITOR_TOPIC */


/* End CONST: TOPIC_MONITOR_TOPIC */


/* Begin CONST: PUBLISHER_MONITOR_TOPIC */


/* End CONST: PUBLISHER_MONITOR_TOPIC */


/* Begin CONST: SUBSCRIBER_MONITOR_TOPIC */


/* End CONST: SUBSCRIBER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_MONITOR_TOPIC */


/* End CONST: DATA_READER_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: TRANSPORT_MONITOR_TOPIC */


/* End CONST: TRANSPORT_MONITOR_TOPIC */


/* Begin STRUCT: Statistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::Statistics& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::Statistics& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::Statistics& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::Statistics>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::Statistics*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Statistics */


/* Begin ENUM: ValueEnumType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::ValueEnumType& enumval);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::ValueEnumType& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export extern const char* gen_OpenDDS_DCPS_ValueEnumType_names[];
OpenDDS_monitor_Export extern const size_t gen_OpenDDS_DCPS_ValueEnumType_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: ValueEnumType */


/* Begin UNION: ValueUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::ValueUnion& uni, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::ValueUnion& uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::ValueUnion& uni);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ValueUnion*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: ValueUnion */


/* Begin STRUCT: NameValuePair */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::NameValuePair& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::NameValuePair& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::NameValuePair& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::NameValuePair>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::NameValuePair*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: NameValuePair */


/* Begin TYPEDEF: NVPSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::NVPSeq& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::NVPSeq& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::NVPSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::NVPSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: NVPSeq */


/* Begin STRUCT: ServiceParticipantReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::ServiceParticipantReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::ServiceParticipantReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::ServiceParticipantReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::ServiceParticipantReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::ServiceParticipantReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::ServiceParticipantReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return false; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export ServiceParticipantReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::ServiceParticipantReport& v1, const OpenDDS::DCPS::ServiceParticipantReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.host < v2.host) return true;
    if (v2.host < v1.host) return false;
    if (v1.pid < v2.pid) return true;
    if (v2.pid < v1.pid) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class ServiceParticipantReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::ServiceParticipantReport> {
  typedef OpenDDS::DCPS::ServiceParticipantReport MessageType;
  typedef OpenDDS::DCPS::ServiceParticipantReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::ServiceParticipantReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::ServiceParticipantReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::ServiceParticipantReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::ServiceParticipantReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::ServiceParticipantReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::ServiceParticipantReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export ServiceParticipantReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ServiceParticipantReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<ServiceParticipantReport> TraitsType;
  typedef ServiceParticipantReportTypeSupport TypeSupportType;
  typedef ServiceParticipantReportTypeSupport::_var_type _var_type;
  typedef ServiceParticipantReportTypeSupport::_ptr_type _ptr_type;

  ServiceParticipantReportTypeSupportImpl() {}
  virtual ~ServiceParticipantReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static ServiceParticipantReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::ServiceParticipantReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ServiceParticipantReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ServiceParticipantReport */


/* Begin STRUCT: DomainParticipantReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DomainParticipantReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DomainParticipantReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DomainParticipantReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DomainParticipantReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DomainParticipantReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::DomainParticipantReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DomainParticipantReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DomainParticipantReport& v1, const OpenDDS::DCPS::DomainParticipantReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[ 9] < v2.dp_id.guidPrefix[ 9]) return true;
    if (v2.dp_id.guidPrefix[ 9] < v1.dp_id.guidPrefix[ 9]) return false;
    if (v1.dp_id.guidPrefix[ 8] < v2.dp_id.guidPrefix[ 8]) return true;
    if (v2.dp_id.guidPrefix[ 8] < v1.dp_id.guidPrefix[ 8]) return false;
    if (v1.dp_id.guidPrefix[ 7] < v2.dp_id.guidPrefix[ 7]) return true;
    if (v2.dp_id.guidPrefix[ 7] < v1.dp_id.guidPrefix[ 7]) return false;
    if (v1.dp_id.guidPrefix[ 6] < v2.dp_id.guidPrefix[ 6]) return true;
    if (v2.dp_id.guidPrefix[ 6] < v1.dp_id.guidPrefix[ 6]) return false;
    if (v1.dp_id.guidPrefix[ 5] < v2.dp_id.guidPrefix[ 5]) return true;
    if (v2.dp_id.guidPrefix[ 5] < v1.dp_id.guidPrefix[ 5]) return false;
    if (v1.dp_id.guidPrefix[ 4] < v2.dp_id.guidPrefix[ 4]) return true;
    if (v2.dp_id.guidPrefix[ 4] < v1.dp_id.guidPrefix[ 4]) return false;
    if (v1.dp_id.guidPrefix[ 3] < v2.dp_id.guidPrefix[ 3]) return true;
    if (v2.dp_id.guidPrefix[ 3] < v1.dp_id.guidPrefix[ 3]) return false;
    if (v1.dp_id.guidPrefix[ 2] < v2.dp_id.guidPrefix[ 2]) return true;
    if (v2.dp_id.guidPrefix[ 2] < v1.dp_id.guidPrefix[ 2]) return false;
    if (v1.dp_id.guidPrefix[ 1] < v2.dp_id.guidPrefix[ 1]) return true;
    if (v2.dp_id.guidPrefix[ 1] < v1.dp_id.guidPrefix[ 1]) return false;
    if (v1.dp_id.guidPrefix[ 0] < v2.dp_id.guidPrefix[ 0]) return true;
    if (v2.dp_id.guidPrefix[ 0] < v1.dp_id.guidPrefix[ 0]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DomainParticipantReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::DomainParticipantReport> {
  typedef OpenDDS::DCPS::DomainParticipantReport MessageType;
  typedef OpenDDS::DCPS::DomainParticipantReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::DomainParticipantReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::DomainParticipantReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::DomainParticipantReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::DomainParticipantReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::DomainParticipantReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::DomainParticipantReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DomainParticipantReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DomainParticipantReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<DomainParticipantReport> TraitsType;
  typedef DomainParticipantReportTypeSupport TypeSupportType;
  typedef DomainParticipantReportTypeSupport::_var_type _var_type;
  typedef DomainParticipantReportTypeSupport::_ptr_type _ptr_type;

  DomainParticipantReportTypeSupportImpl() {}
  virtual ~DomainParticipantReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static DomainParticipantReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DomainParticipantReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DomainParticipantReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantReport */


/* Begin STRUCT: TopicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::TopicReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::TopicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::TopicReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::TopicReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::TopicReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::TopicReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::TopicReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::TopicReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::TopicReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export TopicReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::TopicReport& v1, const OpenDDS::DCPS::TopicReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.topic_id.guidPrefix[11] < v2.topic_id.guidPrefix[11]) return true;
    if (v2.topic_id.guidPrefix[11] < v1.topic_id.guidPrefix[11]) return false;
    if (v1.topic_id.guidPrefix[10] < v2.topic_id.guidPrefix[10]) return true;
    if (v2.topic_id.guidPrefix[10] < v1.topic_id.guidPrefix[10]) return false;
    if (v1.topic_id.guidPrefix[ 9] < v2.topic_id.guidPrefix[ 9]) return true;
    if (v2.topic_id.guidPrefix[ 9] < v1.topic_id.guidPrefix[ 9]) return false;
    if (v1.topic_id.guidPrefix[ 8] < v2.topic_id.guidPrefix[ 8]) return true;
    if (v2.topic_id.guidPrefix[ 8] < v1.topic_id.guidPrefix[ 8]) return false;
    if (v1.topic_id.guidPrefix[ 7] < v2.topic_id.guidPrefix[ 7]) return true;
    if (v2.topic_id.guidPrefix[ 7] < v1.topic_id.guidPrefix[ 7]) return false;
    if (v1.topic_id.guidPrefix[ 6] < v2.topic_id.guidPrefix[ 6]) return true;
    if (v2.topic_id.guidPrefix[ 6] < v1.topic_id.guidPrefix[ 6]) return false;
    if (v1.topic_id.guidPrefix[ 5] < v2.topic_id.guidPrefix[ 5]) return true;
    if (v2.topic_id.guidPrefix[ 5] < v1.topic_id.guidPrefix[ 5]) return false;
    if (v1.topic_id.guidPrefix[ 4] < v2.topic_id.guidPrefix[ 4]) return true;
    if (v2.topic_id.guidPrefix[ 4] < v1.topic_id.guidPrefix[ 4]) return false;
    if (v1.topic_id.guidPrefix[ 3] < v2.topic_id.guidPrefix[ 3]) return true;
    if (v2.topic_id.guidPrefix[ 3] < v1.topic_id.guidPrefix[ 3]) return false;
    if (v1.topic_id.guidPrefix[ 2] < v2.topic_id.guidPrefix[ 2]) return true;
    if (v2.topic_id.guidPrefix[ 2] < v1.topic_id.guidPrefix[ 2]) return false;
    if (v1.topic_id.guidPrefix[ 1] < v2.topic_id.guidPrefix[ 1]) return true;
    if (v2.topic_id.guidPrefix[ 1] < v1.topic_id.guidPrefix[ 1]) return false;
    if (v1.topic_id.guidPrefix[ 0] < v2.topic_id.guidPrefix[ 0]) return true;
    if (v2.topic_id.guidPrefix[ 0] < v1.topic_id.guidPrefix[ 0]) return false;
    if (v1.topic_id.entityId.entityKey[2] < v2.topic_id.entityId.entityKey[2]) return true;
    if (v2.topic_id.entityId.entityKey[2] < v1.topic_id.entityId.entityKey[2]) return false;
    if (v1.topic_id.entityId.entityKey[1] < v2.topic_id.entityId.entityKey[1]) return true;
    if (v2.topic_id.entityId.entityKey[1] < v1.topic_id.entityId.entityKey[1]) return false;
    if (v1.topic_id.entityId.entityKey[0] < v2.topic_id.entityId.entityKey[0]) return true;
    if (v2.topic_id.entityId.entityKey[0] < v1.topic_id.entityId.entityKey[0]) return false;
    if (v1.topic_id.entityId.entityKind < v2.topic_id.entityId.entityKind) return true;
    if (v2.topic_id.entityId.entityKind < v1.topic_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class TopicReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::TopicReport> {
  typedef OpenDDS::DCPS::TopicReport MessageType;
  typedef OpenDDS::DCPS::TopicReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::TopicReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::TopicReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::TopicReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::TopicReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::TopicReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::TopicReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export TopicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<TopicReport> TraitsType;
  typedef TopicReportTypeSupport TypeSupportType;
  typedef TopicReportTypeSupport::_var_type _var_type;
  typedef TopicReportTypeSupport::_ptr_type _ptr_type;

  TopicReportTypeSupportImpl() {}
  virtual ~TopicReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static TopicReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TopicReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::TopicReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicReport */


/* Begin STRUCT: PublisherReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::PublisherReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::PublisherReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::PublisherReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::PublisherReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::PublisherReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::PublisherReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::PublisherReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::PublisherReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::PublisherReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export PublisherReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::PublisherReport& v1, const OpenDDS::DCPS::PublisherReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.handle < v2.handle) return true;
    if (v2.handle < v1.handle) return false;
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[ 9] < v2.dp_id.guidPrefix[ 9]) return true;
    if (v2.dp_id.guidPrefix[ 9] < v1.dp_id.guidPrefix[ 9]) return false;
    if (v1.dp_id.guidPrefix[ 8] < v2.dp_id.guidPrefix[ 8]) return true;
    if (v2.dp_id.guidPrefix[ 8] < v1.dp_id.guidPrefix[ 8]) return false;
    if (v1.dp_id.guidPrefix[ 7] < v2.dp_id.guidPrefix[ 7]) return true;
    if (v2.dp_id.guidPrefix[ 7] < v1.dp_id.guidPrefix[ 7]) return false;
    if (v1.dp_id.guidPrefix[ 6] < v2.dp_id.guidPrefix[ 6]) return true;
    if (v2.dp_id.guidPrefix[ 6] < v1.dp_id.guidPrefix[ 6]) return false;
    if (v1.dp_id.guidPrefix[ 5] < v2.dp_id.guidPrefix[ 5]) return true;
    if (v2.dp_id.guidPrefix[ 5] < v1.dp_id.guidPrefix[ 5]) return false;
    if (v1.dp_id.guidPrefix[ 4] < v2.dp_id.guidPrefix[ 4]) return true;
    if (v2.dp_id.guidPrefix[ 4] < v1.dp_id.guidPrefix[ 4]) return false;
    if (v1.dp_id.guidPrefix[ 3] < v2.dp_id.guidPrefix[ 3]) return true;
    if (v2.dp_id.guidPrefix[ 3] < v1.dp_id.guidPrefix[ 3]) return false;
    if (v1.dp_id.guidPrefix[ 2] < v2.dp_id.guidPrefix[ 2]) return true;
    if (v2.dp_id.guidPrefix[ 2] < v1.dp_id.guidPrefix[ 2]) return false;
    if (v1.dp_id.guidPrefix[ 1] < v2.dp_id.guidPrefix[ 1]) return true;
    if (v2.dp_id.guidPrefix[ 1] < v1.dp_id.guidPrefix[ 1]) return false;
    if (v1.dp_id.guidPrefix[ 0] < v2.dp_id.guidPrefix[ 0]) return true;
    if (v2.dp_id.guidPrefix[ 0] < v1.dp_id.guidPrefix[ 0]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class PublisherReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::PublisherReport> {
  typedef OpenDDS::DCPS::PublisherReport MessageType;
  typedef OpenDDS::DCPS::PublisherReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::PublisherReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::PublisherReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::PublisherReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::PublisherReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::PublisherReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::PublisherReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export PublisherReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublisherReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<PublisherReport> TraitsType;
  typedef PublisherReportTypeSupport TypeSupportType;
  typedef PublisherReportTypeSupport::_var_type _var_type;
  typedef PublisherReportTypeSupport::_ptr_type _ptr_type;

  PublisherReportTypeSupportImpl() {}
  virtual ~PublisherReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static PublisherReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::PublisherReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::PublisherReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublisherReport */


/* Begin STRUCT: SubscriberReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::SubscriberReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::SubscriberReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::SubscriberReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::SubscriberReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::SubscriberReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::SubscriberReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export SubscriberReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::SubscriberReport& v1, const OpenDDS::DCPS::SubscriberReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.handle < v2.handle) return true;
    if (v2.handle < v1.handle) return false;
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[ 9] < v2.dp_id.guidPrefix[ 9]) return true;
    if (v2.dp_id.guidPrefix[ 9] < v1.dp_id.guidPrefix[ 9]) return false;
    if (v1.dp_id.guidPrefix[ 8] < v2.dp_id.guidPrefix[ 8]) return true;
    if (v2.dp_id.guidPrefix[ 8] < v1.dp_id.guidPrefix[ 8]) return false;
    if (v1.dp_id.guidPrefix[ 7] < v2.dp_id.guidPrefix[ 7]) return true;
    if (v2.dp_id.guidPrefix[ 7] < v1.dp_id.guidPrefix[ 7]) return false;
    if (v1.dp_id.guidPrefix[ 6] < v2.dp_id.guidPrefix[ 6]) return true;
    if (v2.dp_id.guidPrefix[ 6] < v1.dp_id.guidPrefix[ 6]) return false;
    if (v1.dp_id.guidPrefix[ 5] < v2.dp_id.guidPrefix[ 5]) return true;
    if (v2.dp_id.guidPrefix[ 5] < v1.dp_id.guidPrefix[ 5]) return false;
    if (v1.dp_id.guidPrefix[ 4] < v2.dp_id.guidPrefix[ 4]) return true;
    if (v2.dp_id.guidPrefix[ 4] < v1.dp_id.guidPrefix[ 4]) return false;
    if (v1.dp_id.guidPrefix[ 3] < v2.dp_id.guidPrefix[ 3]) return true;
    if (v2.dp_id.guidPrefix[ 3] < v1.dp_id.guidPrefix[ 3]) return false;
    if (v1.dp_id.guidPrefix[ 2] < v2.dp_id.guidPrefix[ 2]) return true;
    if (v2.dp_id.guidPrefix[ 2] < v1.dp_id.guidPrefix[ 2]) return false;
    if (v1.dp_id.guidPrefix[ 1] < v2.dp_id.guidPrefix[ 1]) return true;
    if (v2.dp_id.guidPrefix[ 1] < v1.dp_id.guidPrefix[ 1]) return false;
    if (v1.dp_id.guidPrefix[ 0] < v2.dp_id.guidPrefix[ 0]) return true;
    if (v2.dp_id.guidPrefix[ 0] < v1.dp_id.guidPrefix[ 0]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class SubscriberReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::SubscriberReport> {
  typedef OpenDDS::DCPS::SubscriberReport MessageType;
  typedef OpenDDS::DCPS::SubscriberReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::SubscriberReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::SubscriberReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::SubscriberReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::SubscriberReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::SubscriberReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::SubscriberReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export SubscriberReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriberReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SubscriberReport> TraitsType;
  typedef SubscriberReportTypeSupport TypeSupportType;
  typedef SubscriberReportTypeSupport::_var_type _var_type;
  typedef SubscriberReportTypeSupport::_ptr_type _ptr_type;

  SubscriberReportTypeSupportImpl() {}
  virtual ~SubscriberReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SubscriberReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::SubscriberReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::SubscriberReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriberReport */


/* Begin STRUCT: DataWriterAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataWriterAssociation& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterAssociation& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterAssociation& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterAssociation>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterAssociation*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterAssociation */


/* Begin TYPEDEF: DWAssociations */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DWAssociations& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DWAssociations& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DWAssociations& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DWAssociations*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DWAssociations */


/* Begin STRUCT: DataWriterReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataWriterReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataWriterReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataWriterReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::DataWriterReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DataWriterReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DataWriterReport& v1, const OpenDDS::DCPS::DataWriterReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dw_id.guidPrefix[11] < v2.dw_id.guidPrefix[11]) return true;
    if (v2.dw_id.guidPrefix[11] < v1.dw_id.guidPrefix[11]) return false;
    if (v1.dw_id.guidPrefix[10] < v2.dw_id.guidPrefix[10]) return true;
    if (v2.dw_id.guidPrefix[10] < v1.dw_id.guidPrefix[10]) return false;
    if (v1.dw_id.guidPrefix[ 9] < v2.dw_id.guidPrefix[ 9]) return true;
    if (v2.dw_id.guidPrefix[ 9] < v1.dw_id.guidPrefix[ 9]) return false;
    if (v1.dw_id.guidPrefix[ 8] < v2.dw_id.guidPrefix[ 8]) return true;
    if (v2.dw_id.guidPrefix[ 8] < v1.dw_id.guidPrefix[ 8]) return false;
    if (v1.dw_id.guidPrefix[ 7] < v2.dw_id.guidPrefix[ 7]) return true;
    if (v2.dw_id.guidPrefix[ 7] < v1.dw_id.guidPrefix[ 7]) return false;
    if (v1.dw_id.guidPrefix[ 6] < v2.dw_id.guidPrefix[ 6]) return true;
    if (v2.dw_id.guidPrefix[ 6] < v1.dw_id.guidPrefix[ 6]) return false;
    if (v1.dw_id.guidPrefix[ 5] < v2.dw_id.guidPrefix[ 5]) return true;
    if (v2.dw_id.guidPrefix[ 5] < v1.dw_id.guidPrefix[ 5]) return false;
    if (v1.dw_id.guidPrefix[ 4] < v2.dw_id.guidPrefix[ 4]) return true;
    if (v2.dw_id.guidPrefix[ 4] < v1.dw_id.guidPrefix[ 4]) return false;
    if (v1.dw_id.guidPrefix[ 3] < v2.dw_id.guidPrefix[ 3]) return true;
    if (v2.dw_id.guidPrefix[ 3] < v1.dw_id.guidPrefix[ 3]) return false;
    if (v1.dw_id.guidPrefix[ 2] < v2.dw_id.guidPrefix[ 2]) return true;
    if (v2.dw_id.guidPrefix[ 2] < v1.dw_id.guidPrefix[ 2]) return false;
    if (v1.dw_id.guidPrefix[ 1] < v2.dw_id.guidPrefix[ 1]) return true;
    if (v2.dw_id.guidPrefix[ 1] < v1.dw_id.guidPrefix[ 1]) return false;
    if (v1.dw_id.guidPrefix[ 0] < v2.dw_id.guidPrefix[ 0]) return true;
    if (v2.dw_id.guidPrefix[ 0] < v1.dw_id.guidPrefix[ 0]) return false;
    if (v1.dw_id.entityId.entityKey[2] < v2.dw_id.entityId.entityKey[2]) return true;
    if (v2.dw_id.entityId.entityKey[2] < v1.dw_id.entityId.entityKey[2]) return false;
    if (v1.dw_id.entityId.entityKey[1] < v2.dw_id.entityId.entityKey[1]) return true;
    if (v2.dw_id.entityId.entityKey[1] < v1.dw_id.entityId.entityKey[1]) return false;
    if (v1.dw_id.entityId.entityKey[0] < v2.dw_id.entityId.entityKey[0]) return true;
    if (v2.dw_id.entityId.entityKey[0] < v1.dw_id.entityId.entityKey[0]) return false;
    if (v1.dw_id.entityId.entityKind < v2.dw_id.entityId.entityKind) return true;
    if (v2.dw_id.entityId.entityKind < v1.dw_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DataWriterReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::DataWriterReport> {
  typedef OpenDDS::DCPS::DataWriterReport MessageType;
  typedef OpenDDS::DCPS::DataWriterReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::DataWriterReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::DataWriterReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::DataWriterReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::DataWriterReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::DataWriterReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::DataWriterReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DataWriterReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<DataWriterReport> TraitsType;
  typedef DataWriterReportTypeSupport TypeSupportType;
  typedef DataWriterReportTypeSupport::_var_type _var_type;
  typedef DataWriterReportTypeSupport::_ptr_type _ptr_type;

  DataWriterReportTypeSupportImpl() {}
  virtual ~DataWriterReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static DataWriterReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterReport */


/* Begin STRUCT: DataWriterAssociationPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataWriterAssociationPeriodic& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterAssociationPeriodic& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterAssociationPeriodic& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterAssociationPeriodic>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterAssociationPeriodic*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterAssociationPeriodic */


/* Begin TYPEDEF: DWAssociationsPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DWAssociationsPeriodic& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DWAssociationsPeriodic& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DWAssociationsPeriodic& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DWAssociationsPeriodic*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DWAssociationsPeriodic */


/* Begin STRUCT: DataWriterPeriodicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataWriterPeriodicReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterPeriodicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterPeriodicReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataWriterPeriodicReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataWriterPeriodicReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::DataWriterPeriodicReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DataWriterPeriodicReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DataWriterPeriodicReport& v1, const OpenDDS::DCPS::DataWriterPeriodicReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dw_id.guidPrefix[11] < v2.dw_id.guidPrefix[11]) return true;
    if (v2.dw_id.guidPrefix[11] < v1.dw_id.guidPrefix[11]) return false;
    if (v1.dw_id.guidPrefix[10] < v2.dw_id.guidPrefix[10]) return true;
    if (v2.dw_id.guidPrefix[10] < v1.dw_id.guidPrefix[10]) return false;
    if (v1.dw_id.guidPrefix[ 9] < v2.dw_id.guidPrefix[ 9]) return true;
    if (v2.dw_id.guidPrefix[ 9] < v1.dw_id.guidPrefix[ 9]) return false;
    if (v1.dw_id.guidPrefix[ 8] < v2.dw_id.guidPrefix[ 8]) return true;
    if (v2.dw_id.guidPrefix[ 8] < v1.dw_id.guidPrefix[ 8]) return false;
    if (v1.dw_id.guidPrefix[ 7] < v2.dw_id.guidPrefix[ 7]) return true;
    if (v2.dw_id.guidPrefix[ 7] < v1.dw_id.guidPrefix[ 7]) return false;
    if (v1.dw_id.guidPrefix[ 6] < v2.dw_id.guidPrefix[ 6]) return true;
    if (v2.dw_id.guidPrefix[ 6] < v1.dw_id.guidPrefix[ 6]) return false;
    if (v1.dw_id.guidPrefix[ 5] < v2.dw_id.guidPrefix[ 5]) return true;
    if (v2.dw_id.guidPrefix[ 5] < v1.dw_id.guidPrefix[ 5]) return false;
    if (v1.dw_id.guidPrefix[ 4] < v2.dw_id.guidPrefix[ 4]) return true;
    if (v2.dw_id.guidPrefix[ 4] < v1.dw_id.guidPrefix[ 4]) return false;
    if (v1.dw_id.guidPrefix[ 3] < v2.dw_id.guidPrefix[ 3]) return true;
    if (v2.dw_id.guidPrefix[ 3] < v1.dw_id.guidPrefix[ 3]) return false;
    if (v1.dw_id.guidPrefix[ 2] < v2.dw_id.guidPrefix[ 2]) return true;
    if (v2.dw_id.guidPrefix[ 2] < v1.dw_id.guidPrefix[ 2]) return false;
    if (v1.dw_id.guidPrefix[ 1] < v2.dw_id.guidPrefix[ 1]) return true;
    if (v2.dw_id.guidPrefix[ 1] < v1.dw_id.guidPrefix[ 1]) return false;
    if (v1.dw_id.guidPrefix[ 0] < v2.dw_id.guidPrefix[ 0]) return true;
    if (v2.dw_id.guidPrefix[ 0] < v1.dw_id.guidPrefix[ 0]) return false;
    if (v1.dw_id.entityId.entityKey[2] < v2.dw_id.entityId.entityKey[2]) return true;
    if (v2.dw_id.entityId.entityKey[2] < v1.dw_id.entityId.entityKey[2]) return false;
    if (v1.dw_id.entityId.entityKey[1] < v2.dw_id.entityId.entityKey[1]) return true;
    if (v2.dw_id.entityId.entityKey[1] < v1.dw_id.entityId.entityKey[1]) return false;
    if (v1.dw_id.entityId.entityKey[0] < v2.dw_id.entityId.entityKey[0]) return true;
    if (v2.dw_id.entityId.entityKey[0] < v1.dw_id.entityId.entityKey[0]) return false;
    if (v1.dw_id.entityId.entityKind < v2.dw_id.entityId.entityKind) return true;
    if (v2.dw_id.entityId.entityKind < v1.dw_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DataWriterPeriodicReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::DataWriterPeriodicReport> {
  typedef OpenDDS::DCPS::DataWriterPeriodicReport MessageType;
  typedef OpenDDS::DCPS::DataWriterPeriodicReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::DataWriterPeriodicReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::DataWriterPeriodicReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::DataWriterPeriodicReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::DataWriterPeriodicReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::DataWriterPeriodicReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::DataWriterPeriodicReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DataWriterPeriodicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterPeriodicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<DataWriterPeriodicReport> TraitsType;
  typedef DataWriterPeriodicReportTypeSupport TypeSupportType;
  typedef DataWriterPeriodicReportTypeSupport::_var_type _var_type;
  typedef DataWriterPeriodicReportTypeSupport::_ptr_type _ptr_type;

  DataWriterPeriodicReportTypeSupportImpl() {}
  virtual ~DataWriterPeriodicReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static DataWriterPeriodicReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterPeriodicReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterPeriodicReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterPeriodicReport */


/* Begin STRUCT: DataReaderAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataReaderAssociation& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderAssociation& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderAssociation& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderAssociation>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderAssociation*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderAssociation */


/* Begin TYPEDEF: DRAssociations */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DRAssociations& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DRAssociations& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DRAssociations& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DRAssociations*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DRAssociations */


/* Begin STRUCT: DataReaderReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataReaderReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataReaderReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataReaderReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::DataReaderReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DataReaderReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DataReaderReport& v1, const OpenDDS::DCPS::DataReaderReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dr_id.guidPrefix[11] < v2.dr_id.guidPrefix[11]) return true;
    if (v2.dr_id.guidPrefix[11] < v1.dr_id.guidPrefix[11]) return false;
    if (v1.dr_id.guidPrefix[10] < v2.dr_id.guidPrefix[10]) return true;
    if (v2.dr_id.guidPrefix[10] < v1.dr_id.guidPrefix[10]) return false;
    if (v1.dr_id.guidPrefix[ 9] < v2.dr_id.guidPrefix[ 9]) return true;
    if (v2.dr_id.guidPrefix[ 9] < v1.dr_id.guidPrefix[ 9]) return false;
    if (v1.dr_id.guidPrefix[ 8] < v2.dr_id.guidPrefix[ 8]) return true;
    if (v2.dr_id.guidPrefix[ 8] < v1.dr_id.guidPrefix[ 8]) return false;
    if (v1.dr_id.guidPrefix[ 7] < v2.dr_id.guidPrefix[ 7]) return true;
    if (v2.dr_id.guidPrefix[ 7] < v1.dr_id.guidPrefix[ 7]) return false;
    if (v1.dr_id.guidPrefix[ 6] < v2.dr_id.guidPrefix[ 6]) return true;
    if (v2.dr_id.guidPrefix[ 6] < v1.dr_id.guidPrefix[ 6]) return false;
    if (v1.dr_id.guidPrefix[ 5] < v2.dr_id.guidPrefix[ 5]) return true;
    if (v2.dr_id.guidPrefix[ 5] < v1.dr_id.guidPrefix[ 5]) return false;
    if (v1.dr_id.guidPrefix[ 4] < v2.dr_id.guidPrefix[ 4]) return true;
    if (v2.dr_id.guidPrefix[ 4] < v1.dr_id.guidPrefix[ 4]) return false;
    if (v1.dr_id.guidPrefix[ 3] < v2.dr_id.guidPrefix[ 3]) return true;
    if (v2.dr_id.guidPrefix[ 3] < v1.dr_id.guidPrefix[ 3]) return false;
    if (v1.dr_id.guidPrefix[ 2] < v2.dr_id.guidPrefix[ 2]) return true;
    if (v2.dr_id.guidPrefix[ 2] < v1.dr_id.guidPrefix[ 2]) return false;
    if (v1.dr_id.guidPrefix[ 1] < v2.dr_id.guidPrefix[ 1]) return true;
    if (v2.dr_id.guidPrefix[ 1] < v1.dr_id.guidPrefix[ 1]) return false;
    if (v1.dr_id.guidPrefix[ 0] < v2.dr_id.guidPrefix[ 0]) return true;
    if (v2.dr_id.guidPrefix[ 0] < v1.dr_id.guidPrefix[ 0]) return false;
    if (v1.dr_id.entityId.entityKey[2] < v2.dr_id.entityId.entityKey[2]) return true;
    if (v2.dr_id.entityId.entityKey[2] < v1.dr_id.entityId.entityKey[2]) return false;
    if (v1.dr_id.entityId.entityKey[1] < v2.dr_id.entityId.entityKey[1]) return true;
    if (v2.dr_id.entityId.entityKey[1] < v1.dr_id.entityId.entityKey[1]) return false;
    if (v1.dr_id.entityId.entityKey[0] < v2.dr_id.entityId.entityKey[0]) return true;
    if (v2.dr_id.entityId.entityKey[0] < v1.dr_id.entityId.entityKey[0]) return false;
    if (v1.dr_id.entityId.entityKind < v2.dr_id.entityId.entityKind) return true;
    if (v2.dr_id.entityId.entityKind < v1.dr_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DataReaderReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::DataReaderReport> {
  typedef OpenDDS::DCPS::DataReaderReport MessageType;
  typedef OpenDDS::DCPS::DataReaderReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::DataReaderReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::DataReaderReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::DataReaderReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::DataReaderReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::DataReaderReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::DataReaderReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DataReaderReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<DataReaderReport> TraitsType;
  typedef DataReaderReportTypeSupport TypeSupportType;
  typedef DataReaderReportTypeSupport::_var_type _var_type;
  typedef DataReaderReportTypeSupport::_ptr_type _ptr_type;

  DataReaderReportTypeSupportImpl() {}
  virtual ~DataReaderReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static DataReaderReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderReport */


/* Begin STRUCT: DataReaderAssociationPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataReaderAssociationPeriodic& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderAssociationPeriodic& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderAssociationPeriodic& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderAssociationPeriodic>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderAssociationPeriodic*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderAssociationPeriodic */


/* Begin TYPEDEF: DRAssociationsPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DRAssociationsPeriodic& seq, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DRAssociationsPeriodic& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DRAssociationsPeriodic& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DRAssociationsPeriodic*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DRAssociationsPeriodic */


/* Begin STRUCT: DataReaderPeriodicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::DataReaderPeriodicReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderPeriodicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderPeriodicReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataReaderPeriodicReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataReaderPeriodicReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::DataReaderPeriodicReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export DataReaderPeriodicReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::DataReaderPeriodicReport& v1, const OpenDDS::DCPS::DataReaderPeriodicReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dr_id.guidPrefix[11] < v2.dr_id.guidPrefix[11]) return true;
    if (v2.dr_id.guidPrefix[11] < v1.dr_id.guidPrefix[11]) return false;
    if (v1.dr_id.guidPrefix[10] < v2.dr_id.guidPrefix[10]) return true;
    if (v2.dr_id.guidPrefix[10] < v1.dr_id.guidPrefix[10]) return false;
    if (v1.dr_id.guidPrefix[ 9] < v2.dr_id.guidPrefix[ 9]) return true;
    if (v2.dr_id.guidPrefix[ 9] < v1.dr_id.guidPrefix[ 9]) return false;
    if (v1.dr_id.guidPrefix[ 8] < v2.dr_id.guidPrefix[ 8]) return true;
    if (v2.dr_id.guidPrefix[ 8] < v1.dr_id.guidPrefix[ 8]) return false;
    if (v1.dr_id.guidPrefix[ 7] < v2.dr_id.guidPrefix[ 7]) return true;
    if (v2.dr_id.guidPrefix[ 7] < v1.dr_id.guidPrefix[ 7]) return false;
    if (v1.dr_id.guidPrefix[ 6] < v2.dr_id.guidPrefix[ 6]) return true;
    if (v2.dr_id.guidPrefix[ 6] < v1.dr_id.guidPrefix[ 6]) return false;
    if (v1.dr_id.guidPrefix[ 5] < v2.dr_id.guidPrefix[ 5]) return true;
    if (v2.dr_id.guidPrefix[ 5] < v1.dr_id.guidPrefix[ 5]) return false;
    if (v1.dr_id.guidPrefix[ 4] < v2.dr_id.guidPrefix[ 4]) return true;
    if (v2.dr_id.guidPrefix[ 4] < v1.dr_id.guidPrefix[ 4]) return false;
    if (v1.dr_id.guidPrefix[ 3] < v2.dr_id.guidPrefix[ 3]) return true;
    if (v2.dr_id.guidPrefix[ 3] < v1.dr_id.guidPrefix[ 3]) return false;
    if (v1.dr_id.guidPrefix[ 2] < v2.dr_id.guidPrefix[ 2]) return true;
    if (v2.dr_id.guidPrefix[ 2] < v1.dr_id.guidPrefix[ 2]) return false;
    if (v1.dr_id.guidPrefix[ 1] < v2.dr_id.guidPrefix[ 1]) return true;
    if (v2.dr_id.guidPrefix[ 1] < v1.dr_id.guidPrefix[ 1]) return false;
    if (v1.dr_id.guidPrefix[ 0] < v2.dr_id.guidPrefix[ 0]) return true;
    if (v2.dr_id.guidPrefix[ 0] < v1.dr_id.guidPrefix[ 0]) return false;
    if (v1.dr_id.entityId.entityKey[2] < v2.dr_id.entityId.entityKey[2]) return true;
    if (v2.dr_id.entityId.entityKey[2] < v1.dr_id.entityId.entityKey[2]) return false;
    if (v1.dr_id.entityId.entityKey[1] < v2.dr_id.entityId.entityKey[1]) return true;
    if (v2.dr_id.entityId.entityKey[1] < v1.dr_id.entityId.entityKey[1]) return false;
    if (v1.dr_id.entityId.entityKey[0] < v2.dr_id.entityId.entityKey[0]) return true;
    if (v2.dr_id.entityId.entityKey[0] < v1.dr_id.entityId.entityKey[0]) return false;
    if (v1.dr_id.entityId.entityKind < v2.dr_id.entityId.entityKind) return true;
    if (v2.dr_id.entityId.entityKind < v1.dr_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DataReaderPeriodicReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::DataReaderPeriodicReport> {
  typedef OpenDDS::DCPS::DataReaderPeriodicReport MessageType;
  typedef OpenDDS::DCPS::DataReaderPeriodicReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::DataReaderPeriodicReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::DataReaderPeriodicReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::DataReaderPeriodicReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::DataReaderPeriodicReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::DataReaderPeriodicReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::DataReaderPeriodicReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DataReaderPeriodicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderPeriodicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<DataReaderPeriodicReport> TraitsType;
  typedef DataReaderPeriodicReportTypeSupport TypeSupportType;
  typedef DataReaderPeriodicReportTypeSupport::_var_type _var_type;
  typedef DataReaderPeriodicReportTypeSupport::_ptr_type _ptr_type;

  DataReaderPeriodicReportTypeSupportImpl() {}
  virtual ~DataReaderPeriodicReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static DataReaderPeriodicReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderPeriodicReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderPeriodicReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderPeriodicReport */


/* Begin STRUCT: TransportReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::TransportReport& stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportReport& stru);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(const OpenDDS::DCPS::TransportReport& stru, bool align);

OpenDDS_monitor_Export
size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::TransportReport> stru, bool align);

OpenDDS_monitor_Export
void gen_find_size(KeyOnly<const OpenDDS::DCPS::TransportReport> stru, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::TransportReport> stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::TransportReport> stru);

template <>
struct MarshalTraits<OpenDDS::DCPS::TransportReport> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return false; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct OpenDDS_monitor_Export TransportReport_OpenDDS_KeyLessThan {
  bool operator()(const OpenDDS::DCPS::TransportReport& v1, const OpenDDS::DCPS::TransportReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.host < v2.host) return true;
    if (v2.host < v1.host) return false;
    if (v1.pid < v2.pid) return true;
    if (v2.pid < v1.pid) return false;
    if (v1.transport_id < v2.transport_id) return true;
    if (v2.transport_id < v1.transport_id) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class TransportReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<OpenDDS::DCPS::TransportReport> {
  typedef OpenDDS::DCPS::TransportReport MessageType;
  typedef OpenDDS::DCPS::TransportReportSeq MessageSequenceType;
  typedef OpenDDS::DCPS::TransportReportTypeSupport TypeSupportType;
  typedef OpenDDS::DCPS::TransportReportTypeSupportImpl TypeSupportTypeImpl;
  typedef OpenDDS::DCPS::TransportReportDataWriter DataWriterType;
  typedef OpenDDS::DCPS::TransportReportDataReader DataReaderType;
  typedef OpenDDS::DCPS::TransportReport_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "OpenDDS::DCPS::TransportReport"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export TransportReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TransportReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<TransportReport> TraitsType;
  typedef TransportReportTypeSupport TypeSupportType;
  typedef TransportReportTypeSupport::_var_type _var_type;
  typedef TransportReportTypeSupport::_ptr_type _ptr_type;

  TransportReportTypeSupportImpl() {}
  virtual ~TransportReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static TransportReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TransportReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportReport */


/* Begin ENUM: ReportType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReportType& enumval);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::ReportType& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export extern const char* gen_OpenDDS_DCPS_ReportType_names[];
OpenDDS_monitor_Export extern const size_t gen_OpenDDS_DCPS_ReportType_names_size;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: ReportType */


/* Begin UNION: GenericReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void gen_find_size(const OpenDDS::DCPS::GenericReport& uni, size_t& size, size_t& padding);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const OpenDDS::DCPS::GenericReport& uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, OpenDDS::DCPS::GenericReport& uni);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::GenericReport*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: GenericReport */


/* Begin INTERFACE: ProcessMonitor */


/* End INTERFACE: ProcessMonitor */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
#endif /* OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_8WWFDX */
