// --------------------------------------------------------------------------
// |              _    _ _______     .----.      _____         _____        |
// |         /\  | |  | |__   __|  .  ____ .    / ____|  /\   |  __ \       |
// |        /  \ | |  | |  | |    .  / __ \ .  | (___   /  \  | |__) |      |
// |       / /\ \| |  | |  | |   .  / / / / v   \___ \ / /\ \ |  _  /       |
// |      / /__\ \ |__| |  | |   . / /_/ /  .   ____) / /__\ \| | \ \       |
// |     /________\____/   |_|   ^ \____/  .   |_____/________\_|  \_\      |
// |                              . _ _  .                                  |
// --------------------------------------------------------------------------
//
// All Rights Reserved.
// Any use of this source code is subject to a license agreement with the
// AUTOSAR development cooperation.
// More information is available at www.autosar.org.
//
// Disclaimer
//
// This work (specification and/or software implementation) and the material
// contained in it, as released by AUTOSAR, is for the purpose of information
// only. AUTOSAR and the companies that have contributed to it shall not be
// liable for any use of the work.
//
// The material contained in this work is protected by copyright and other
// types of intellectual property rights. The commercial exploitation of the
// material contained in this work requires a license to such intellectual
// property rights.
//
// This work may be utilized or reproduced without any modification, in any
// form or by any means, for informational purposes only. For any other
// purpose, no part of the work may be utilized or reproduced, in any form
// or by any means, without permission in writing from the publisher.
//
// The work has been developed for automotive applications only. It has
// neither been developed, nor tested for non-automotive applications.
//
// The word AUTOSAR and the AUTOSAR logo are registered trademarks.
// --------------------------------------------------------------------------

#ifndef ARA_VSOMEIP_BINDING_INCLUDES_LIBARA_INTERNAL_COMMON_VSOMEIP_MARSHALLING_H_
#define ARA_VSOMEIP_BINDING_INCLUDES_LIBARA_INTERNAL_COMMON_VSOMEIP_MARSHALLING_H_

#include <vsomeip/vsomeip.hpp>

#include <type_traits>
#include <cstdint>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include "ara/core/error_code.h"
#include "ara/core/map.h"
#include "ara/core/vector.h"
#include "ara/core/array.h"
#include "ara/core/string.h"
#include "ara/core/optional.h"
#include "vsomeip_error_domains.h"

namespace ara
{
namespace com
{
namespace internal
{
namespace vsomeip
{
namespace common
{

/**
 * \defgroup vsomeipmarshalling VSOMEIP Marshalling
 *
 * \brief This is the API for marshalling for vsomeip_binding for diffreent data type.
 *
 * It contains Serialization and Deserialization methods for data types that can be copied by a memcpy or that provide
 * an enumerate method. In addition, there are also serializers for some standard types like ara::core::String,
 * ara::core::Vector,etc.
 *
 * @{
 */

enum class WireTypes : std::uint16_t
{
    base_8bit = 0U,
    base_16bit = 1U,
    base_32bit = 2U,
    base_64bit = 3U,
    complex_with_length = 4U,
    complex_force_length_8 = 5U,
    complex_force_length_16 = 6U,
    complex_force_length_32 = 7U
};

/**
 * \brief Helper class that determines if the given type contains a typedef named "IsEnumerableTag".
 *
 * This tag is generated by the ara::com generator to indicate that the given type (struct or class) has an enumerate
 * method that simply calls a callable with each member as its argument.
 *
 */
template <typename T, typename Tagged = void>
struct is_enumerable
{
    static const bool value = false;  ///< Indicates if T::IsEnumerableTag exists.
};

/**
 * \brief This is the specialization that will be used if T::IsEnumerableTag exists.
 */
template <typename T>
struct is_enumerable<T, typename T::IsEnumerableTag>
{
    static const bool value = true;
};

/**
 * \brief Helper class that determines if the given type contains a typedef named "LengthFieldPresent".
 */
template <typename T, typename Tagged = void>
struct has_length_field
{
    static const bool value = false;
};

/**
 * \brief This is the specialization that will be used if T::LengthFieldPresent exists.
 */
template <typename T>
struct has_length_field<T, typename T::LengthFieldPresent>
{
    static const bool value = true;
};

/**
 * \brief Helper class that determines if the given type contains a typedef named "Is_TLV_tag".
 */
template <typename T, typename Tagged = void>
struct is_tlv
{
    static const bool value = false;
};

/**
 * \brief This is the specialization that will be used if T::Is_TLV_tag exists.
 */
template <typename T>
struct is_tlv<T, typename T::Is_TLV_tag>
{
    static const bool value = true;
};

template <typename T>
using is_string = std::is_same<T, ara::core::String>;

template <typename T>
using EnableIfBaseType = typename std::enable_if<std::is_scalar<T>::value>::type;

template <typename T>
using EnableIfComplexType = typename std::enable_if<!std::is_scalar<T>::value>::type;

template <typename T>
using EnableIfImplementationDataType = typename std::enable_if<is_enumerable<T>::value>::type;

template <typename T>
using EnableIfSerializeWithLength = typename std::enable_if<has_length_field<T>::value>::type;

template <typename T>
using EnableIfMembersAreTLV = typename std::enable_if<is_tlv<T>::value>::type;

template <typename T>
using EnableIfOptional = typename std::enable_if<ara::core::is_optional<T>::value>::type;

/**
 * \brief Checks if the value is serializable.
 *
 * Currently this is true if the type is either scalar (you can transfer the object state with a simple
 * memcpy), string or if the struct has a generated enumerate function.
 *
 * \return true if serializable else false
 */
template <typename T>
constexpr bool IsSerializable()
{
    return std::is_scalar<T>::value || is_enumerable<T>::value || has_length_field<T>::value || is_tlv<T>::value
        || is_string<T>::value;
}

class EndianChecker
{
public:
    static bool isLittleEndianHost()
    {
        std::uint32_t test_number = 0x1;
        std::uint8_t* test_bytes = reinterpret_cast<std::uint8_t*>(&test_number);
        return (test_bytes[0] == 1);
    }
};

template <typename T>
class Serializer;

/**
 * \brief Functor that serializes all forwarded values to the given byte array.
 *
 * Its call operator takes any type and attempts to instantiate a Serializer for it. This serializer is then used to
 * turn the value into its byte representation which is then appended to the given array.
 *
 * Usage: Serializer passes this as an argument to struct enumerate() method to apply operator() to every field of
 * struct
 */
template <typename Container>
class SerializingEnumerator
{
public:
    SerializingEnumerator(Container& payload_data)
        : payload_data_(payload_data)
    { }

    template <typename T>
    void operator()(const T& value)
    {
        Serializer<T> serializer(value);
        serializer.pushbackTo(payload_data_);
    }

private:
    Container& payload_data_;
};

/* [PRS_SOMEIP_00202] DRAFT The length of a tag shall be two bytes. */
template <typename Container, typename OuterStruct, typename tag_field_type = std::uint16_t>
class TLV_Enumerator
{
public:
    TLV_Enumerator(Container& payload_data)
        : payload_data_(payload_data)
    { }

    template <typename T>
    std::uint16_t wire_type_mask(EnableIfBaseType<T>* = nullptr)
    {
        constexpr size_t typeSizeBytes = sizeof(T);
        static_assert((typeSizeBytes == 1) || (typeSizeBytes == 2) || (typeSizeBytes == 4) || (typeSizeBytes == 8),
            "wrong size for base type!");
        /* TODO: probably changing switch to template specialization would save some ticks */
        std::uint16_t result = 0;
        switch (typeSizeBytes) {
        case 1: {
            result = static_cast<std::uint16_t>(WireTypes::base_8bit);
            break;
        }
        case 2: {
            result = static_cast<std::uint16_t>(WireTypes::base_16bit);
            break;
        }
        case 4: {
            result = static_cast<std::uint16_t>(WireTypes::base_32bit);
            break;
        }
        case 8: {
            result = static_cast<std::uint16_t>(WireTypes::base_64bit);
            break;
        }
        default: {
            break;
        }
        }
        return (result << 12);
    }

    template <typename T>
    std::uint16_t wire_type_mask(EnableIfComplexType<T>* = nullptr)
    {
        return (static_cast<std::uint16_t>(WireTypes::complex_with_length) << 12);
    }

    template <typename T>
    std::uint16_t wire_type_mask(EnableIfOptional<T>* = nullptr)
    {
        return wire_type_mask<T::value_type>();
    }

    /*
     * [PRS_SOMEIP_00203]
     * [PRS_SOMEIP_00212]
     * [PRS_SOMEIP_00203]
     * [PRS_SOMEIP_00204]
     * [PRS_SOMEIP_00205]
     * [PRS_SOMEIP_00212]
     */
    template <typename T>
    void operator()(const T& value, tag_field_type data_id, EnableIfBaseType<T>* = nullptr)
    {
        tag_field_type tag = (data_id & 0x0fff) | wire_type_mask<T>();

        Serializer<tag_field_type> tag_serializer(tag);
        tag_serializer.pushbackTo(payload_data_);
        Serializer<T> serializer(value);
        serializer.pushbackTo(payload_data_);
    }

    /*
     * [PRS_SOMEIP_00203]
     * [PRS_SOMEIP_00213]
     * [PRS_SOMEIP_00214]
     * [PRS_SOMEIP_00221]
     */
    template <typename T>
    void operator()(const T& value, tag_field_type data_id, EnableIfComplexType<T>* = nullptr)
    {
        using length_field_type = typename OuterStruct::TLVLengthFieldType;

        tag_field_type tag = (data_id & 0x0fff) | wire_type_mask<T>();

        Serializer<tag_field_type> tag_serializer(tag);
        tag_serializer.pushbackTo(payload_data_);
        auto start_size = payload_data_.size();
        Serializer<T> serializer(value);
        serializer.pushbackTo(payload_data_);
        length_field_type len = payload_data_.size() - start_size;
        Serializer<length_field_type>(len).insertTo(std::inserter(payload_data_, payload_data_.end() - len));
    }

    template <typename T>
    void operator()(const ara::core::Optional<T>& value, tag_field_type data_id)
    {
        if (value) {
            operator()(*value, data_id);
        }
    }

private:
    Container& payload_data_;
};

/**
 * \brief Serializes the given type.
 *
 * This class is used to serialize the given type to a byte string that can be sent over the wire. There is a base
 * version that relies on the type either being TriviallyCopyable (you can transfer the object state with a simple
 * memcpy) or the type being enumerable. In the latter case, the type is serialized by serializing each individual
 * member using the enumerate method of the type.
 *
 * If the type is neither TriviallyCopyable nor does an enumerate function exist, then this class template needs to be
 * specialized. See below for a list of currently existing specializations.
 *
 */
template <typename T>
class Serializer
{
public:
    using value_type = typename std::decay<T>::type;
    /**
     * Constructs a serializer for the given value of type T.
     *
     * If there is no specialization and the type is neither TriviallyCopyable nor has an enumerate method, compilation
     * fails.
     *
     * \param value Value that shall be serialized.
     */
    Serializer(const value_type& value)
        : value_(value)
    {
        static_assert(IsSerializable<value_type>(), "No appropriate marshalling defined for this type!");
    }

    /**
     * \brief Adds the bytes that contain the serialized object to the given container using its push_back method.
     *
     * Since the push_back method is used, the provided type has to provide one that accepts a type that
     * ::vsomeip::byte_t
     * (aka unsigned char) converts into.
     *
     * \param c Container that shall receive the serialized byte stream.
     */
    template <typename Container>
    void pushbackTo(Container& c)
    {
        pushbackToHelper(c);
    }

    // Inserts the bytes starting from out_iterator place
    template <typename Iterator>
    void insertTo(Iterator out_iterator)
    {
        insertToHelper(out_iterator);
    }

private:
    const value_type& value_;

    /**
     * \brief Helper function that is used if the type is TriviallyCopyable.
     *
     * In this case, the value is simply aliased to a pointer to unsigned char and copied byte-wise.
     *
     * The second parameter is only used to select the appropriate version of pushbackToHelper.
     *
     * \param c Container that shall receive the serialized byte stream.
     */
    template <typename Container, typename U = value_type>
    void pushbackToHelper(Container& c, EnableIfBaseType<U>* = nullptr)
    {
        const ::vsomeip::byte_t* data = reinterpret_cast<const ::vsomeip::byte_t*>(&value_);
        std::copy(data, data + sizeof(value_), std::back_inserter(c));

        if (EndianChecker::isLittleEndianHost()) {
            std::reverse(c.end() - sizeof(value_), c.end());
        }
    }
    /**
     * \brief Helper function that is used if the type is not TriviallyCopyable but has an enumerate function.
     *
     * This version of pushbackToHelper uses enumerate to serialize the type member-wise.
     *
     * The second parameter is only used to select the appropriate version of pushbackToHelper.
     *
     * \param c Container that shall receive the serialized byte stream.
     */
    template <typename Container, typename U = value_type>
    void pushbackToHelper(Container& c, EnableIfImplementationDataType<U>* = nullptr)
    {
        SerializingEnumerator<Container> enumerator(c);
        /* We need the const_cast here because the generated 'enumerate' method is non-const as it shall be possible to
         * also
         * change the contents of the struct if needed, e.g. during member-wise deserialization. In order to DRY, we
         * do not generate a const-version of enumerate either. The only possible solution is const_cast then, and since
         * SerializingEnumerator's operator() takes its argument as const, we still respect the const-ness of our member
         * variable. */
        const_cast<value_type&>(value_).enumerate(enumerator);
    }

    /*
     * @uptrace{SWS_CM_10218, df82c397ebdb7ba8aca561771b7f2819b27fd9b2}
     */
    template <typename Container, typename U = value_type>
    void pushbackToHelper(Container& c, EnableIfSerializeWithLength<U>* = nullptr)
    {
        using length_field_type = typename U::LengthFieldType;
        auto start_size = c.size();
        SerializingEnumerator<Container> enumerator(c);
        const_cast<value_type&>(value_).enumerate(enumerator);
        length_field_type len = c.size() - start_size;
        Serializer<length_field_type>(len).insertTo(std::inserter(c, c.end() - len));
    }

    template <typename Container, typename U = value_type>
    void pushbackToHelper(Container& c, EnableIfMembersAreTLV<U>* = nullptr)
    {
        using length_field_type = typename U::LengthFieldType;
        auto start_size = c.size();
        TLV_Enumerator<Container, U> enumerator(c);
        const_cast<value_type&>(value_).enumerate(enumerator);
        length_field_type len = c.size() - start_size;
        Serializer<length_field_type>(len).insertTo(std::inserter(c, c.end() - len));
    }

    template <typename Iterator, typename U = value_type, typename = EnableIfBaseType<U>>
    void insertToHelper(Iterator out_iterator)
    {
        const ::vsomeip::byte_t* data = reinterpret_cast<const ::vsomeip::byte_t*>(&value_);

        if (EndianChecker::isLittleEndianHost()) {
            ::vsomeip::byte_t intermediate_data[sizeof(value_)];
            std::copy(data, data + sizeof(value_), intermediate_data);
            std::reverse(intermediate_data, intermediate_data + sizeof(intermediate_data));
            std::copy(intermediate_data, intermediate_data + sizeof(intermediate_data), out_iterator);
        } else {
            std::copy(data, data + sizeof(value_), out_iterator);
        }
    }
};

/// \brief UTF-8 encoding helper.
class UTF_8
{
public:
    using bom_type = std::array<uint8_t, 3>;

    static constexpr bom_type bom_{0xEF, 0xBB, 0xBF};

    template <typename Container>
    static void appendBom(Container& c)
    {
        Serializer<uint8_t>(bom_[0]).pushbackTo(c);
        Serializer<uint8_t>(bom_[1]).pushbackTo(c);
        Serializer<uint8_t>(bom_[2]).pushbackTo(c);
    }

    static bool isEncodingValid(const uint8_t* c_string, size_t size)
    {
        bool retVal
            = c_string[0] != bom_[0] ? false : c_string[1] != bom_[1] ? false : c_string[2] != bom_[2] ? false : true;

        if (c_string[size - sizeof('\0')] != '\0') {
            retVal = false;
        }

        return retVal;
    }

    static constexpr size_t encodingSizeOverhead()
    {
        return bom_.size() + sizeof('\0');
    }
};

/**
 * \brief Specialization for ara::core::String.
 *
 * \see \ref Serializer main template for a description of the methods.
 *
 */

template <>
class Serializer<ara::core::String>
{
public:
    using value_type = ara::core::String;
    /*
     * as per SWS_CommunicationManagement, length field
     * represents length in _bytes_
     */
    using length_field_type = std::uint32_t;

    Serializer(const value_type& value)
        : str_(value)
    { }

    template <typename Container>
    void pushbackTo(Container& c)
    {
        // Append size of BOM and null character as well
        length_field_type len = UTF_8::bom_.size() + str_.size() + sizeof('\0');
        Serializer<length_field_type>(len).pushbackTo(c);
        UTF_8::appendBom(c);
        const typename Container::value_type* nullTerminatedStringBegin
            = reinterpret_cast<const typename Container::value_type*>(str_.c_str());
        const typename Container::value_type* nullTerminatedStringEnd  // past the null terminator
            = nullTerminatedStringBegin + str_.size() + sizeof('\0');
        std::copy(nullTerminatedStringBegin, nullTerminatedStringEnd, std::back_inserter(c));
    }

private:
    const ara::core::String& str_;
};

struct ErrorCodeTransformationProps
{
    using union_length_type = std::uint32_t;
    using union_type_type = std::uint8_t;
    using struct_length_type = std::uint16_t;
    using domain_value_type = std::uint64_t;
    using error_code_type = std::uint32_t;
    using support_data_type = std::uint32_t;
    static constexpr struct_length_type struct_length_bytes
        = sizeof(domain_value_type) + sizeof(error_code_type) + sizeof(support_data_type);
    static constexpr union_length_type union_length_bytes
        = sizeof(struct_length_type) + sizeof(union_type_type) + struct_length_bytes;
};

/**
 * \brief Specialization for ara::core::ErrorCode.
 *
 * \see \ref Serializer main template for a description of the methods.
 *
 */
template <>
class Serializer<ara::core::ErrorCode>
{
public:
    Serializer(const ara::core::ErrorCode& value)
        : err_(value)
    { }

    template <typename Container>
    void pushbackTo(Container& c)
    {
        auto struct_length = ErrorCodeTransformationProps::struct_length_bytes;
        auto union_length = ErrorCodeTransformationProps::union_length_bytes;
        /** @uptrace{SWS_CM_10428, 1e3b962bc0c308aa5d4fc1832379d2db3c883f30} */
        Serializer<ErrorCodeTransformationProps::union_length_type>(union_length).pushbackTo(c);
        Serializer<ErrorCodeTransformationProps::union_type_type>(0x01).pushbackTo(c);
        Serializer<ErrorCodeTransformationProps::struct_length_type>(struct_length).pushbackTo(c);
        Serializer<ErrorCodeTransformationProps::domain_value_type>(err_.Domain().Id()).pushbackTo(c);
        Serializer<ErrorCodeTransformationProps::error_code_type>(err_.Value()).pushbackTo(c);
        Serializer<ErrorCodeTransformationProps::support_data_type>(err_.SupportData()).pushbackTo(c);
    }

private:
    const ara::core::ErrorCode& err_;
};

/**
 * \brief Specialization to serialize a pair of values.
 *
 * This class is mostly used to serialize ara::core::Map and std::unordered_map.
 *
 * \tparam First Type of the first value
 * \tparam Second Type of the second value
 */
template <typename First, typename Second>
class Serializer<std::pair<First, Second>>
{
public:
    using value_type = std::pair<First, Second>;

    Serializer(const value_type& value)
        : value_(value)
    { }

    /**
     * \brief Serializes the contents of the container to the given container that needs to be able to receive numeric
     * values.
     * \param c Container to receive the serialized value.
     */
    template <typename Container>
    void pushbackTo(Container& c)
    {
        Serializer<typename std::decay<First>::type> first_serializer(value_.first);
        Serializer<typename std::decay<Second>::type> second_serializer(value_.second);
        first_serializer.pushbackTo(c);
        second_serializer.pushbackTo(c);
    }

private:
    const value_type& value_;  ///< pair to be serialized
};

/**
 * \brief Specialization to serialize an array of values.
 *
 * This class is used to serialize c-style arrays and ara::core::Array through another specialization that derives from
 * this class
 *
 * \tparam T Type of the array elements
 * \tparam N Size of the array
 */
template <typename T, std::size_t N>
class Serializer<ara::core::Array<T, N>>
{
public:
    using value_type = ara::core::Array<T, N>;

    Serializer(const value_type& value)
        : value_(value)
    { }

    /**
     * \brief Serializes the contents of the container to the given container that needs to be able to receive numeric
     * values.
     * \param c Container to receive the serialized value.
     */
    template <typename Container>
    void pushbackTo(Container& c)
    {
        for (std::size_t i = 0; i < N; ++i) {
            Serializer<T> serializer(value_[i]);
            serializer.pushbackTo(c);
        }
    }

private:
    const value_type& value_;  ///< array to be serialized
};

/**
 * \brief Serializes all containers that satisfy Sequence
 *
 * The value needs to be serializable as well in order for this class to compile properly.
 *
 */
template <typename Sequence>
class SequenceContainerSerializer
{
public:
    using value_type = Sequence;
    /*
     * as per SWS_CommunicationManagement, length field
     * represents length in _bytes_
     */
    using length_field_type = std::uint32_t;

    SequenceContainerSerializer(const Sequence& container)
        : container_(container)
    { }

    /**
     * \brief Serializes the contents of the container to the given container that needs to be able to receive numeric
     * values.
     * \param c Container to receive the serialized value.
     */
    template <typename TargetContainer>
    void pushbackTo(TargetContainer& c)
    {
        auto start_size = c.size();
        for (const typename Sequence::value_type& item : container_) {
            Serializer<typename Sequence::value_type> serializer(item);
            serializer.pushbackTo(c);
        }
        length_field_type len = c.size() - start_size;
        Serializer<length_field_type>(len).insertTo(std::inserter(c, c.end() - len));
    }

private:
    const Sequence& container_;  ///< Container to be serialized.
};

/**
 * \brief Specialization for ara::core::Vector.
 *
 * \see \ref Serializer main template for a description of the methods.
 *
 */
template <typename T>
class Serializer<ara::core::Vector<T>>
{
public:
    using value_type = ara::core::Vector<T>;
    /*
     * as per SWS_CommunicationManagement, length field
     * represents length in _bytes_
     */
    using length_field_type = std::uint32_t;

    Serializer(const value_type& value)
        : container_(value)
    { }

    template <typename Container>
    void pushbackTo(Container& c)
    {
        pushbackToHelper(c);
    }

private:
    const value_type& container_;

    template <typename Container, typename U = T>
    void pushbackToHelper(Container& c)
    {
        SequenceContainerSerializer<ara::core::Vector<T>> serializer(container_);
        serializer.pushbackTo(c);
    }
};

/**
 * \brief Template specialization of Serializer for ara::core::Map
 */
template <typename K, typename V, typename Compare, typename Allocator>
class Serializer<ara::core::Map<K, V, Compare, Allocator>>
    : public SequenceContainerSerializer<ara::core::Map<K, V, Compare, Allocator>>
{
public:
    using SequenceContainerSerializer<ara::core::Map<K, V, Compare, Allocator>>::SequenceContainerSerializer;
};

/**
 * \brief Template specialization of Serializer for std::unordered_map
 */
template <typename K, typename V, typename Hash, typename KeyEqual, typename Allocator>
class Serializer<std::unordered_map<K, V, Hash, KeyEqual, Allocator>>
    : public SequenceContainerSerializer<std::unordered_map<K, V, Hash, KeyEqual, Allocator>>
{
public:
    using SequenceContainerSerializer<std::unordered_map<K, V, Hash, KeyEqual, Allocator>>::SequenceContainerSerializer;
};

/**
 * \brief Template specialization of Serializer for std::set
 */
template <typename K, typename Compare, typename Allocator>
class Serializer<std::set<K, Compare, Allocator>> : public SequenceContainerSerializer<std::set<K, Compare, Allocator>>
{
public:
    using SequenceContainerSerializer<std::set<K, Compare, Allocator>>::SequenceContainerSerializer;
};

/**
 * \brief Template specialization of Serializer for std::unordered_set
 */
template <typename K, typename Hash, typename KeyEqual, typename Allocator>
class Serializer<std::unordered_set<K, Hash, KeyEqual, Allocator>>
    : public SequenceContainerSerializer<std::unordered_set<K, Hash, KeyEqual, Allocator>>
{
public:
    using SequenceContainerSerializer<std::unordered_set<K, Hash, KeyEqual, Allocator>>::SequenceContainerSerializer;
};

template <typename T>
class Deserializer;

/**
 * \brief Functor that assigns the deserialized value to whatever it is given via its call operator.
 *
 * DeserializingEnumerator consumes the bytes during deserialization. If, for whatever reasons, a past-the-end
 * read would happen, the call operator raises an std::runtime_error.
 *
 */
class DeserializingEnumerator
{
public:
    /**
     * \brief Constructs a DeserializingEnumerator that serializes into the given payload.
     *
     * \param payload Payload to serialize to.
     */
    explicit DeserializingEnumerator(std::shared_ptr<::vsomeip::payload> payload)
        : data_(payload->get_data())
        , size_(payload->get_length())
        , pos_(0)
    { }

    /**
     * \brief Constructs a DeserializingEnumerator that deserializes from the given raw byte array.
     *
     * \param data Data to deserialize from.
     * \param size Length of the given array.
     */
    DeserializingEnumerator(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
        , size_(size)
        , pos_(0)
    { }

    /**
     * \brief Deserializes the value of type T from the input byte string and assigns it to the given value reference.
     *
     * If the requested type is larger than the remaining bytes of the input array, the method will throw an
     * std::runtime_error.
     *
     * \param value Value reference that shall be set to the deserialized value.
     */
    template <typename T>
    void operator()(T& value)
    {
        Deserializer<T> deserializer(data_ + pos_, size_ - pos_);
        pos_ += deserializer.getSize();
        if (pos_ > size_) {
            throw std::runtime_error("Insufficient arguments from remote end");
        } else {
            value = deserializer.getValue();
        }
    }

    template <typename T>
    void operator()(ara::core::Optional<T>& value)
    {
        Deserializer<T> deserializer(data_ + pos_, size_ - pos_);
        pos_ += deserializer.getSize();
        if (pos_ > size_) {
            throw std::runtime_error("Insufficient arguments from remote end");
        } else {
            value = deserializer.getValue();
        }
    }

private:
    const ::vsomeip::byte_t* data_;  ///< Array to deserialize from.
    std::size_t size_;  ///< Size of the input array.
    std::size_t pos_;  ///< Current position at which the next deserialization will happen.
};

/**
 * \brief Calculates the serialized size of a struct that has an enumerate method.
 *
 * Since it is possible to have data types that have a variable length, depending on their contents (for example
 * ara::core::String), the receiving end doesn't know exactly how the memory layout looks like. Therefore, this class
 * determines, what space the given type takes within the given byte string. It does this by partly deserializing the
 * contents, decoding only the information that is needed to determine the length.
 *
 */
class SizeCounter
{
public:
    /**
     * \brief Constructs a SizeCounter from the given byte array.
     * \param data
     * \param buf_size
     * \return
     */
    SizeCounter(const ::vsomeip::byte_t* data, std::size_t buf_size)
        : buf_size_(buf_size)
        , data_(data)
    { }

    /**
     * \brief Called on each member of the struct, calculating the size of the member and the position of the next
     * member.
     *
     * This method doesn't actually access its argument (aka the struct members). Therefore it is safe (but scary) to
     * use
     * an arbitrary memory location as the struct instance.
     */
    template <typename T>
    void operator()(const T&)
    {
        Deserializer<T> deserializer(data_, buf_size_);
        std::size_t size = deserializer.getSize();
        size_ += size;
        data_ += size;
        buf_size_ -= size;
    }

    /**
     * \brief Returns the size of the struct.
     *
     * This function may be called after having called enumerate of the target struct to learn how many bytes the struct
     * takes inside the given byte string.
     *
     * \return Size of the enumerated struct.
     */
    std::size_t GetSize() const
    {
        return size_;
    }

private:
    std::size_t size_{0};  ///< Size counter. Updated by the call operator.
    std::size_t buf_size_;  ///< Maximum buffer size.
    const ::vsomeip::byte_t* data_;  ///< Array to use as input for the deserialization of the length information.
};

/**
 * \brief Deserializes the state of a given type using the provided byte string.
 *
 * This class is used to deserialize the state of an object of the given type from a byte string that was received from
 * a file. There is a base version that relies on the type either being TriviallyCopyable (you can transfer the object
 * state with a simple memcpy) or the type being enumerable. In the latter case, the type is deserialized by
 * deserializing each individual member using the enumerate method of the type.
 *
 * If the type is neither TriviallyCopyable nor does an enumerate function exist, then this class template needs to be
 * specialized.
 *
 */
template <typename T>
class Deserializer
{
public:
    using value_type = typename std::decay<T>::type;
    /**
     * \brief Type of the value that is returned as the deserialized object.
     */
    using result_type = value_type;

    /**
     * \brief Constructs a deserializer for the given type using the data provided in the byte array.
     *
     * \param data Byte array to deserialize.
     * \param size Size of the provided array.
     */
    Deserializer(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
        , size_(size)
    {
        static_assert(IsSerializable<value_type>(), "No appropriate marshalling defined for this type!");
    }

    /**
     * \brief Retrieve the deserialized value.
     *
     * If the type is TriviallyCopyable, the returned result is a reference into the byte array. In this case, no copy
     * is
     * made if the call site receives the value in a reference as well. However, the returned value is only valid as
     * long
     * as the byte string that was given to Deserializer is valid.
     *
     * \return Deserialized value.
     */
    result_type getValue() const
    {
        return getValueHelper();
    }

    /**
     * \brief Returns the size the given type occupies in a byte array.
     *
     * If the returned value is added to a pointer pointing to the serialized object state, the pointer points to the
     * byte
     * that immediately follows the serialized object state.
     *
     * The returned size is exactly the number of bytes the deserializer will consume if getValue() is called.
     *
     * \return Size of the serialized object state.
     */
    std::size_t getSize() const
    {
        return getSizeHelper();
    }

private:
    const ::vsomeip::byte_t* data_;
    std::size_t size_;

    /*
     * This version of getValueHelper is used if the type is a base type. In this case, the bytes are used as-is
     * to
     * restore the object state.
     *
     * @uptrace{SWS_CM_10361, a190c1a261dd1ea3885e331d26745928b12ac354}
     */

    template <typename U = value_type>
    result_type getValueHelper(EnableIfBaseType<U>* = nullptr) const
    {
        result_type result{};

        if (sizeof(value_type) > size_) {
            throw std::runtime_error("Deserialization of trivially copyable type failed, insufficient data!");
        }

        if (EndianChecker::isLittleEndianHost()) {
            ::vsomeip::byte_t intermediate_data[sizeof(value_type)];
            std::copy(data_, data_ + sizeof(value_type), intermediate_data);
            std::reverse(intermediate_data, intermediate_data + sizeof(intermediate_data));
            result = *reinterpret_cast<const value_type*>(intermediate_data);
        } else {
            result = *reinterpret_cast<const value_type*>(data_);
        }

        return result;
    }

    /*
     * This version of getValueHelper is used if the type provides an enumerate method. In this case, the object is
     * deserialized on a per-member basis.
     *
     * @uptrace{SWS_CM_10042, 4f5f0f228de90c1e73c780075c026e4b856868d5}
     * @uptrace{SWS_CM_10219, 16f74b99f14aee231204d29c1b58d4430b18be86}
     */
    template <typename U = value_type>
    result_type getValueHelper(EnableIfImplementationDataType<U>* = nullptr) const
    {
        result_type result{};
        DeserializingEnumerator deserializer(data_, size_);

        result.enumerate(deserializer);
        return result;
    }

    template <typename U = value_type>
    result_type getValueHelper(EnableIfSerializeWithLength<U>* = nullptr) const
    {
        using length_field_type = typename U::LengthFieldType;
        if (size_ >= sizeof(length_field_type)) {
            Deserializer<length_field_type> length_deserializer(data_, size_);
            auto len = length_deserializer.getValue();
            if (sizeof(length_field_type) + len > size_) {
                throw std::runtime_error("Deserialization of structure failed, declared size excess data length.");
            }
        } else {
            throw std::runtime_error("Deserialization of structure failed, unable to read size.");
        }
        result_type result{};
        DeserializingEnumerator deserializer(data_ + sizeof(length_field_type), size_ - sizeof(length_field_type));
        result.enumerate(deserializer);
        return result;
    }

    std::size_t length_from_tag(const std::uint16_t tag) const
    {
        std::size_t result = 0;
        switch (static_cast<WireTypes>((tag >> 12) & 0x07)) {
        case WireTypes::base_8bit: {
            result = 1;
            break;
        }
        case WireTypes::base_16bit: {
            result = 2;
            break;
        }
        case WireTypes::base_32bit: {
            result = 4;
            break;
        }
        case WireTypes::base_64bit: {
            result = 8;
            break;
        }
        default: {
            break;
        }
        }
        return result;
    }

    std::uint16_t get_data_id(const std::uint16_t tag) const
    {
        return tag & 0x0FFF;
    }

    /*
     * [PRS_SOMEIP_00217]
     * [PRS_SOMEIP_00218]
     */
    template <typename U = value_type>
    result_type getValueHelper(EnableIfMembersAreTLV<U>* = nullptr) const
    {
        using length_field_type = typename U::LengthFieldType;
        using tlv_len_type = typename U::TLVLengthFieldType;

        length_field_type len = 0;

        if (size_ >= sizeof(length_field_type)) {
            Deserializer<length_field_type> length_deserializer(data_, size_);
            len = length_deserializer.getValue();
            if (sizeof(length_field_type) + len > size_) {
                throw std::runtime_error("Deserialization of structure failed, declared size excess data length.");
            }
        } else {
            throw std::runtime_error("Deserialization of structure failed, unable to read size.");
        }

        result_type result{};
        const ::vsomeip::byte_t* start = data_ + sizeof(length_field_type);
        const ::vsomeip::byte_t* end = start + len;
        const ::vsomeip::byte_t* current = start;
        auto required_fields = result.required_fields();

        for (; current < end;) {
            Deserializer<std::uint16_t> tag_deserializer(current, end - current);
            auto tag = tag_deserializer.getValue();
            current += sizeof(tag);
            auto data_id = get_data_id(tag);
            auto tlv_len = length_from_tag(tag);
            if (tlv_len > 0) {
            } else {
                Deserializer<tlv_len_type> len_deserializer(current, end - current);
                tlv_len = len_deserializer.getValue();
                current += sizeof(tlv_len_type);
            }

            DeserializingEnumerator field_reader(current, tlv_len);
            bool data_id_recognized = result.dispatch(data_id, field_reader);

            if (data_id_recognized) {
                required_fields.erase(data_id);
            }
            current += tlv_len;
        }
        if (!required_fields.empty()) {
            throw std::runtime_error("Failed to deserialize required fields");
        }

        return result;
    }

    /*
     * This version of getSizeHelper is used if the type is TriviallyCopyable. In this case, sizeof() will report the
     * number of bytes that the object occupies in memory.
     */
    template <typename U = value_type, typename = EnableIfBaseType<U>>
    std::size_t getSizeHelper() const
    {
        return sizeof(T);
    }

    /*
     * This version of getSizeHelper is used if the type provides an enumerate method. In this case, the size of the
     * types
     * are accumulated on a per-member basis.
     */
    template <typename U = value_type>
    std::size_t getSizeHelper(EnableIfImplementationDataType<U>* = nullptr) const
    {
        SizeCounter size_counter(data_, size_);
        /* Intentionally leaving this uninitialized as we actually do not need the this pointer as all we do is
         * calculating
         * the size of the datatype which only depends on the data from the byte array and does not access the data
         * itself
         * (see the definition of SizeCounter::operator()) */
        value_type* x = nullptr;
        x->enumerate(size_counter);
        return size_counter.GetSize();
    }

    template <typename U = value_type>
    std::size_t getSizeHelper(EnableIfSerializeWithLength<U>* = nullptr) const
    {
        using length_field_type = typename U::LengthFieldType;
        std::size_t len;
        if (size_ >= sizeof(length_field_type)) {
            Deserializer<length_field_type> length_deserializer(data_, size_);
            len = length_deserializer.getValue();
        } else {
            throw std::runtime_error("Unable to read structure size.");
        }
        return sizeof(length_field_type) + len;
    }

    template <typename U = value_type>
    std::size_t getSizeHelper(EnableIfMembersAreTLV<U>* = nullptr) const
    {
        using length_field_type = typename U::LengthFieldType;
        std::size_t len;
        if (size_ >= sizeof(length_field_type)) {
            Deserializer<length_field_type> length_deserializer(data_, size_);
            len = length_deserializer.getValue();
        } else {
            throw std::runtime_error("Unable to read structure size.");
        }
        return sizeof(length_field_type) + len;
    }
};

/**
 * \brief Template specialization for ara::core::String
 *
 * \see \ref Deserializer main template for method documentation.
 */
template <>
class Deserializer<ara::core::String>
{
public:
    using result_type = ara::core::String;
    using char_type = ara::core::String::value_type;
    /*
     * as per SWS_CommunicationManagement, length field
     * represents length in _bytes_
     * TODO: one more specialization for at least UTF-16 strings
     */
    using length_field_type = std::uint32_t;

    /**
     * \brief Creates a deserializer using the given array.
     *
     * The constructor throws if the given array size is too short to hold the string.
     *
     * \param data Start of byte data.
     * \param size Size of data.
     */
    Deserializer(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
    {
        bool valid = false;
        if (size >= sizeof(length_field_type)) {
            Deserializer<length_field_type> length_deserializer(data, size);
            len_ = length_deserializer.getValue();
            size_t minimumDataSize = len_ + sizeof(length_field_type);
            if (minimumDataSize <= size && UTF_8::encodingSizeOverhead() <= len_) {
                if (UTF_8::isEncodingValid(data + sizeof(length_field_type), len_)) {
                    valid = true;
                } else {
                    throw std::runtime_error("Deserialization of ara::core::String failed, incorrect encoding.");
                }
            }
        }

        if (!valid) {
            throw std::runtime_error("Deserialization of ara::core::String failed, insufficient data.");
        }
    }

    /**
     * \brief Returns the deserialized string.
     * \return Deserialized string.
     */
    result_type getValue() const
    {
        const char_type* c = reinterpret_cast<const char_type*>(data_ + sizeof(length_field_type) + UTF_8::bom_.size());
        return {c, len_ - UTF_8::encodingSizeOverhead()};
    }

    /**
     * \brief Returns the number of bytes the string occupies.
     * \return Size of the string in bytes.
     */
    std::size_t getSize() const
    {
        return sizeof(length_field_type) + len_ * sizeof(char_type);
    }

private:
    const ::vsomeip::byte_t* data_;
    std::size_t len_;
};

/** @uptrace{SWS_CM_10428, 1e3b962bc0c308aa5d4fc1832379d2db3c883f30} */
template <>
class Deserializer<ara::core::ErrorCode>
{
public:
    using result_type = ara::core::ErrorCode;

    Deserializer(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
    {
        bool valid = false;
        auto required_size = ErrorCodeTransformationProps::union_length_bytes + sizeof(union_len);

        if (size == required_size) {
            auto pos = data;
            auto len = size;
            union_len = Deserializer<decltype(union_len)>(pos, len).getValue();
            pos += sizeof(union_len);
            len -= sizeof(union_len);
            union_type = Deserializer<decltype(union_type)>(pos, len).getValue();
            pos += sizeof(union_type);
            len -= sizeof(union_type);
            struct_len = Deserializer<decltype(struct_len)>(pos, len).getValue();
            pos += sizeof(struct_len);
            len -= sizeof(struct_len);
            domain_value = Deserializer<decltype(domain_value)>(pos, len).getValue();
            pos += sizeof(domain_value);
            len -= sizeof(domain_value);
            error_code = Deserializer<decltype(error_code)>(pos, len).getValue();
            pos += sizeof(error_code);
            len -= sizeof(error_code);
            support_data = Deserializer<decltype(support_data)>(pos, len).getValue();

            valid = (union_type == 0x01) && (union_len == ErrorCodeTransformationProps::union_length_bytes)
                && (struct_len == ErrorCodeTransformationProps::struct_length_bytes);

            if (!valid) {
                throw std::runtime_error("Deserialization of ara::core::ErrorCode failed, inconsistent data.");
            }
        } else {
            throw std::runtime_error("Deserialization of ara::core::ErrorCode failed, unexpected data length.");
        }
    }

    result_type getValue() const
    {
        return ara::core::ErrorCode(error_code, error_domains::Registry::getDomain(domain_value), support_data);
    }

    std::size_t getSize() const
    {
        return union_len + sizeof(union_len);
    }

private:
    const ::vsomeip::byte_t* data_;
    ErrorCodeTransformationProps::union_length_type union_len;
    ErrorCodeTransformationProps::union_type_type union_type;
    ErrorCodeTransformationProps::struct_length_type struct_len;
    ErrorCodeTransformationProps::domain_value_type domain_value;
    ErrorCodeTransformationProps::error_code_type error_code;
    ErrorCodeTransformationProps::support_data_type support_data;
};

/**
 * \brief Deserializes all containers that fulfill the SequenceContainer concept.
 */
template <typename Sequence>
class SequenceContainerDeserializer
{
public:
    using result_type = Sequence;
    /*
     * as per SWS_CommunicationManagement, length field
     * represents length in _bytes_
     */
    using length_field_type = std::uint32_t;

    /**
     * \brief Creates a deserializer using the given array.
     *
     * The constructor throws if the given array size is too short to hold the container.
     *
     * \param data Start of byte data.
     * \param size Size of data.
     */
    SequenceContainerDeserializer(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
        , len_()
        , size_(size)
    {
        if (size >= sizeof(length_field_type)) {
            Deserializer<length_field_type> length_deserializer(data, size);
            len_ = length_deserializer.getValue();

            if (sizeof(length_field_type) + len_ > size) {
                throw std::runtime_error("Deserialization of Sequence failed, declared array size excess data length.");
            }
        } else {
            throw std::runtime_error("Deserialization of Sequence failed, insufficient data.");
        }
    }

    /**
     * \brief Creates a deserializer using the given array and assumes the given length.
     *
     * No consistency check is done as this is the duty of the caller. This constructor is used by the Deserializer
     * specialization for ara::core::Vector in case the vector content can't be deserialized using a memcopy.
     *
     * \param data Start of byte data.
     * \param size Size of data.
     * \param len Number of elements in the container.
     */
    SequenceContainerDeserializer(const ::vsomeip::byte_t* data, std::size_t size, std::size_t len)
        : data_(data)
        , size_(size)
        , len_(len)
    { }

    /**
     * \brief Returns the deserialized container.
     *
     * This method may throw if the length of the container (or its contents) does not fit the array size.
     *
     * \return Deserialized container.
     */
    result_type getValue() const
    {
        result_type result{};

        const ::vsomeip::byte_t* current_pos = data_ + sizeof(length_field_type);
        const ::vsomeip::byte_t* end_pos = current_pos + len_;
        std::size_t remaining_size = size_ - sizeof(length_field_type);
        for (; current_pos < end_pos;) {
            Deserializer<typename Sequence::value_type> item_deserializer(current_pos, remaining_size);
            result.push_back(item_deserializer.getValue());

            std::size_t s = item_deserializer.getSize();
            if (remaining_size >= s) {
                current_pos += s;
                remaining_size -= s;
            } else {
                throw std::runtime_error("Deserialization of sequence container failed, insufficient data.");
            }
        }

        return result;
    }

    /**
     * \brief Returns the number of bytes the container and its contents occupy.
     *
     * This method may throw if the length of the container (or its contents) does not fit the array size.
     *
     * \return Number of bytes the container occupies.
     */
    std::size_t getSize() const
    {
        return sizeof(length_field_type) + len_;
    }

private:
    const ::vsomeip::byte_t* data_;
    std::size_t size_;
    std::size_t len_;
};

/**
 * \brief Template specialization for ara::core::Vector.
 *
 * This specialization will detect if the type is TriviallyCopyable. If this is the case, the class will use a memcopy
 * to restore the state. Otherwise, it will use a per-class deserializer.
 *
 * \see \ref Deserializer main template for method documentation.
 */
template <typename T>
class Deserializer<ara::core::Vector<T>>
{
public:
    using result_type = ara::core::Vector<T>;
    /*
     * as per SWS_CommunicationManagement, length field
     * represents length in _bytes_
     */
    using length_field_type = std::uint32_t;

    /**
     * \brief Creates a deserializer using the given array.
     *
     * The constructor throws if the given array size is too short to hold the container.
     *
     * \param data Start of byte data.
     * \param size Size of data.
     */
    Deserializer(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
        , size_(size)
        , len_()
    {
        bool valid = false;

        if (size >= sizeof(length_field_type)) {
            Deserializer<length_field_type> length_deserializer(data, size);
            len_ = length_deserializer.getValue();
            if (sizeof(length_field_type) + len_ <= size) {
                valid = true;
            }
        }

        if (!valid) {
            throw std::runtime_error("Deserialization of ara::core::Vector<T> failed, insufficient data.");
        }
    }

    /**
     * \brief Returns the deserialized container.
     *
     * This method may throw if the length of the container (or its contents) does not fit the array size.
     *
     * \return Deserialized container.
     */
    result_type getValue() const
    {
        return getValueHelper();
    }

    /**
     * \brief Returns the number of bytes the container and its contents occupy.
     *
     * This method may throw if the length of the container (or its contents) does not fit the array size.
     *
     * \return Number of bytes the container occupies.
     */
    std::size_t getSize() const
    {
        return getSizeHelper();
    }

private:
    const ::vsomeip::byte_t* data_;
    std::size_t size_;
    std::size_t len_;

    result_type getValueHelper(void) const
    {
        return SequenceContainerDeserializer<ara::core::Vector<T>>(data_, size_, len_).getValue();
    }

    std::size_t getSizeHelper(void) const
    {
        return SequenceContainerDeserializer<ara::core::Vector<T>>(data_, size_, len_).getSize();
    }
};

/**
 * \brief Template specialization for ara::core::Array.
 *
 * This class adapts its behavior depending on the given type. If this type is TriviallyCopyable, the class will use a
 * simple memcpy, otherwise it will do a member-wise deserialization.
 *
 * \tparam T Type of the array.
 * \tparam N Length of the array.
 */
template <typename T, std::size_t N>
class Deserializer<ara::core::Array<T, N>>
{
public:
    using result_type = ara::core::Array<T, N>;

    Deserializer(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
        , size_(size)
    { }

    /**
     * \brief Returns the deserialized container.
     *
     * This method may throw if the length of the container (or its contents) does not fit the array size.
     *
     * \return Deserialized container.
     */
    result_type getValue() const
    {
        result_type result;

        std::size_t pos = 0;
        for (std::size_t i = 0; i < N; ++i) {
            Deserializer<T> deserializer(data_ + pos, size_ - pos);
            result[i] = deserializer.getValue();
            pos += deserializer.getSize();
        }

        return result;
    }

    /**
     * \brief Returns the number of bytes the container and its contents occupy.
     *
     * This method may throw if the length of the container (or its contents) does not fit the array size.
     *
     * \return Number of bytes the container occupies.
     */
    std::size_t getSize() const
    {
        std::size_t pos = 0;
        for (std::size_t i = 0; i < N; ++i) {
            Deserializer<T> deserializer(data_ + pos, size_ - pos);
            pos += deserializer.getSize();
        }

        return pos;
    }

private:
    const ::vsomeip::byte_t* data_;
    std::size_t size_;
};

template <typename First, typename Second>
class Deserializer<std::pair<First, Second>>
{
public:
    using result_type = std::pair<First, Second>;

    Deserializer(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
        , size_(size)
    { }

    result_type getValue() const
    {
        Deserializer<typename std::decay<First>::type> first_deserializer(data_, size_);
        std::size_t first_size = first_deserializer.getSize();
        if (first_size < size_) {
            Deserializer<typename std::decay<Second>::type> second_deserializer(data_ + first_size, size_ - first_size);
            return result_type(first_deserializer.getValue(), second_deserializer.getValue());
        } else {
            throw std::runtime_error("Deserialization of pair failed, insufficient data.");
        }
    }

    std::size_t getSize() const
    {
        Deserializer<typename std::decay<First>::type> first_deserializer(data_, size_);
        std::size_t first_size = first_deserializer.getSize();
        if (first_size < size_) {
            Deserializer<typename std::decay<Second>::type> second_deserializer(data_ + first_size, size_ - first_size);
            return first_size + second_deserializer.getSize();
        } else {
            throw std::runtime_error("Deserialization of pair failed, insufficient data.");
        }
    }

private:
    const ::vsomeip::byte_t* data_;
    std::size_t size_;
};

/**
 * \brief Deserializes containers that satisfy AssociativeContainer, e.g. ara::core::Map or std::unordered_map.
 */
template <typename AssociativeContainer>
class AssociativeContainerDeserializer
{
public:
    using result_type = AssociativeContainer;
    /*
     * as per SWS_CommunicationManagement, length field
     * represents length in _bytes_
     */
    using length_field_type = std::uint32_t;

    /**
     * \brief Constructs a deserializer from the given byte array.
     *
     * This constructor throws if the given array is too small to even contain the array length.
     *
     * \param data Pointer to the data array.
     * \param size Maximum length of the data array.
     */
    AssociativeContainerDeserializer(const ::vsomeip::byte_t* data, std::size_t size)
        : data_(data)
        , size_(size)
        , len_()
    {
        if (size >= sizeof(length_field_type)) {
            Deserializer<length_field_type> length_deserializer(data, size);
            len_ = length_deserializer.getValue();
            data_ += sizeof(length_field_type);
            size_ -= sizeof(length_field_type);
        } else {
            throw std::runtime_error("Deserialization of associative container failed, insufficient data.");
        }
    }

    /**
     * \brief Returns the deserialized container.
     *
     * This method throws if the given array is too small to contain the number of elements advertised.
     *
     * \return The deserialized container.
     */
    result_type getValue() const
    {
        result_type result{};

        const ::vsomeip::byte_t* pos = data_;
        const ::vsomeip::byte_t* end_pos = data_ + len_;
        std::size_t remaining = size_;

        for (; pos < end_pos;) {
            Deserializer<typename AssociativeContainer::value_type> key_deserializer(pos, remaining);
            result.insert(key_deserializer.getValue());

            std::size_t size_entry = key_deserializer.getSize();
            if (remaining >= size_entry) {
                pos += size_entry;
                remaining -= size_entry;
            } else {
                throw std::runtime_error("Deserialization of sequence container failed, insufficient data.");
            }
        }

        return result;
    }

    /**
     * \brief Returns the length of the serialized container.
     *
     * This method throws if the given array is too small to contain the number of elements advertised.
     *
     * \return Length of the serialized container.
     */
    std::size_t getSize() const
    {
        return sizeof(length_field_type) + len_;
    }

private:
    const ::vsomeip::byte_t* data_;  ///< Pointer to the first data item.
    std::size_t size_;  ///< Maximum length of the array.
    std::size_t len_;  ///< Number of items within the container.
};

/**
 * \brief Template specialization of Deserializer for ara::core::Map
 */
template <typename K, typename V, typename Compare, typename Allocator>
class Deserializer<ara::core::Map<K, V, Compare, Allocator>>
    : public AssociativeContainerDeserializer<ara::core::Map<K, V, Compare, Allocator>>
{
public:
    using AssociativeContainerDeserializer<ara::core::Map<K, V, Compare, Allocator>>::AssociativeContainerDeserializer;
};

/**
 * \brief Template specialization of Deserializer for std::unordered_map
 */
template <typename K, typename V, typename Hash, typename KeyEqual, typename Allocator>
class Deserializer<std::unordered_map<K, V, Hash, KeyEqual, Allocator>>
    : public AssociativeContainerDeserializer<std::unordered_map<K, V, Hash, KeyEqual, Allocator>>
{
public:
    using AssociativeContainerDeserializer<
        std::unordered_map<K, V, Hash, KeyEqual, Allocator>>::AssociativeContainerDeserializer;
};

/**
 * \brief Template specialization of Deserializer for std::set
 */
template <typename K, typename Compare, typename Allocator>
class Deserializer<std::set<K, Compare, Allocator>>
    : public AssociativeContainerDeserializer<std::set<K, Compare, Allocator>>
{
public:
    using AssociativeContainerDeserializer<std::set<K, Compare, Allocator>>::AssociativeContainerDeserializer;
};

/**
 * \brief Template specialization of Deserializer for std::unordered_map
 */
template <typename K, typename Hash, typename KeyEqual, typename Allocator>
class Deserializer<std::unordered_set<K, Hash, KeyEqual, Allocator>>
    : public AssociativeContainerDeserializer<std::unordered_set<K, Hash, KeyEqual, Allocator>>
{
public:
    using AssociativeContainerDeserializer<
        std::unordered_set<K, Hash, KeyEqual, Allocator>>::AssociativeContainerDeserializer;
};

/**
 * \brief Looks for the I'th type in the parameter pack defined by Head, Tail...
 *
 * If you get a compilation error here it most likely means means that the index is out of bounds.
 *
 * \tparam I Index into the parameter pack
 * \tparam Head Head of parameter pack
 * \tparam Tail Tail of the parameter pack
 */
template <std::size_t I, typename Head, typename... Tail>
struct ArgumentTypeImpl
{
    using type = typename ArgumentTypeImpl<I - 1, Tail...>::type;
};

/**
 * Specialization for the base of the template recursion. Returns the Head of the parameter pack. If you get a
 * compilation error here it means that the index is out of bounds.
 */
template <typename Head, typename... Tail>
struct ArgumentTypeImpl<0, Head, Tail...>
{
    using type = Head;
};

/**
 * \brief Returns the I'th type in the parameter pack defined by Args.
 */
template <std::size_t I, typename... Args>
using ArgumentType = typename ArgumentTypeImpl<I, Args...>::type;

/**
 * \brief Selects the appropriate Deserializer for the I'th argument in the parameter pack defined by Args.
 */
template <std::size_t I, typename... Args>
using DeserializerForArg = Deserializer<typename std::decay<ArgumentType<I, Args...>>::type>;

/**
 * \brief Helper struct to calculate the start position of each argument in the parameter pack.
 * \tparam I Number of iterations that still need to be done
 * \tparam Args Arguments to use during the calculation
 */
template <std::size_t I, typename... Args>
struct MessageIndexerImpl
{
    template <typename OutputIter>
    void operator()(std::size_t cur_pos, const std::uint8_t* data, std::size_t size, OutputIter out) const
    {
        *out = cur_pos;
        DeserializerForArg<sizeof...(Args) - I, Args...> deserializer(data + cur_pos, size - cur_pos);
        std::size_t arg_size = deserializer.getSize();
        MessageIndexerImpl<I - 1, Args...> next;
        next(cur_pos + arg_size, data, size, ++out);
    }
};

/**
 * \brief Specialization for the base of the template recursion.
 *
 * Since the number of recursions to go is 0, we just do nothing.
 */
template <typename... Args>
struct MessageIndexerImpl<0, Args...>
{
    template <typename OutputIter>
    void operator()(std::size_t /*cur_pos*/,
        const std::uint8_t* /*data*/,
        std::size_t /*size*/,
        OutputIter /*out*/) const
    { }
};

/**
 * \brief Deserializes a range of types from a VSOMEIP message.
 *
 * The class creates an index of the arguments using the provided type parameters. The provided unmarshal method can
 * then be used with a static index to unmarshal the argument at the given index.
 *
 */
template <typename... Args>
class Unmarshaller
{
public:
    /**
     * \brief Constructs an Unmarshaller that reads its data from the given message.
     * \param m Message to read data from.
     */
    Unmarshaller(::vsomeip::message& message)
        : payload_(message.get_payload())
        , data_(payload_->get_data())
        , size_(payload_->get_length())
        , argument_positions_()
    {
        IndexMessage();
    }

    /**
     * \brief Constructs an Unmarshaller that reads its data from the given raw array.
     * \param data Data to unmarshal
     * \param size Size of the given array
     */
    Unmarshaller(const std::uint8_t* data, std::size_t size)
        : payload_()
        , data_(data)
        , size_(size)
        , argument_positions_()
    {
        IndexMessage();
    }

    /**
     * \brief Deserializes one value from the given message, using the argument index that is provided by the caller.
     *
     * Notice that if the type that is requested would require more bytes than the bytes that are remaining in the byte
     * string, the method will throw an std::runtime_error.
     *
     * \tparam I Index of the argument to be unmarshalled. This must not be larger than the number of arguments
     * provided.
     *
     * \return Deserialized value. Notice that this can also be a reference.
     */
    template <std::size_t I>
    typename DeserializerForArg<I, Args...>::result_type unmarshal() const
    {
        static_assert(I < sizeof...(Args), "Argument index out of bounds!");
        std::size_t pos = argument_positions_[I];
        DeserializerForArg<I, Args...> deserializer(data_ + pos, size_ - pos);
        return deserializer.getValue();
    }

private:
    /**
     * \brief Initializes argument_positions_ with the starting position of each argument in the given payload.
     */
    void IndexMessage()
    {
        MessageIndexerImpl<sizeof...(Args), Args...> indexer;
        indexer(0, data_, size_, &argument_positions_[0]);
    };

    std::shared_ptr<::vsomeip::payload> payload_;  ///< Payload of the message that shall be used as the data source.
    const std::uint8_t* data_;
    std::size_t size_;
    ara::core::Array<std::size_t, sizeof...(Args)>
        argument_positions_;  ///< Index into the payload that indicates the start position of each argument.
};

template <>
class Unmarshaller<>
{
public:
    Unmarshaller(::vsomeip::message&)
    { }
    Unmarshaller(const std::uint8_t*, std::size_t)
    { }
    template <std::size_t I>
    void unmarshal() const
    { }
};

/**
 * \brief Serializes a number of function arguments to the given VSOMEIP payload object.
 *
 * This helper class may be used to serialize an arbitrary number of arguments to the given payload object.
 *
 */
class Marshaller
{
public:
    /**
     * constructor
     * @param payload_data
     */
    Marshaller(ara::core::Vector<std::uint8_t>& payload_data)
        : payload_data_(payload_data)
    { }

    /**
     * \brief Serializes the given parameter pack to the payload object.
     *
     * This function serializes each given argument to the payload object by repeatedly utilizing the appropriate
     * \ref Serializer class and concatenating the resulting byte blocks without any padding. The result can be
     * deserialized again using \ref Unmarshaller.
     *
     * \param args
     */
    template <typename... Args>
    void marshal(Args&&... args)
    {
        doMarshalling(payload_data_, std::forward<Args>(args)...);
    }

private:
    ara::core::Vector<std::uint8_t>& payload_data_;  ///< Data vector the class will serialize into.

    /**
     * \brief Overload that is used in case no arguments are left over (or none were given).
     */
    static void doMarshalling(ara::core::Vector<std::uint8_t>&)
    { }

    /**
     * \brief Overload that serializes one argument and forwards all other arguments recursively to itself.
     *
     * If tail is empty, the next call to doMarshalling will use the overload that doesn't carry any further arguments
     * and
     * acts as a no op, ending recursion.
     *
     * \param payload_data Payload data to serialize to.
     * \param head Argument that will be serialized.
     * \param tail Remaining arguments that are serialized by a recursive call.
     */
    template <typename HEAD, typename... TAIL>
    static void doMarshalling(ara::core::Vector<std::uint8_t>& payload_data, HEAD&& head, TAIL&&... tail)
    {
        Serializer<typename std::decay<HEAD>::type> serializer(head);
        serializer.pushbackTo(payload_data);
        doMarshalling(payload_data, std::forward<TAIL>(tail)...);
    }
};

/** @}*/

}  // namespace common
}  // namespace vsomeip
}  // namespace internal
}  // namespace com
}  // namespace ara

#endif  // ARA_VSOMEIP_BINDING_INCLUDES_LIBARA_INTERNAL_COMMON_VSOMEIP_MARSHALLING_H_
